{
  "address": "0x0562eefAD05870Dd74dEE7d08a338182eB86De25",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_trustedForwarder",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_passkeyVerifier",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_recoveryVerifier",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "LUNA_IMPLEMENTATION",
      "outputs": [
        {
          "internalType": "contract Luna",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "name": "LunaNameToDetails",
      "outputs": [
        {
          "internalType": "address",
          "name": "walletAddress",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "isUsed",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "_passkeyInputs",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "_recoveryHash",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "_email",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "salt",
          "type": "uint256"
        }
      ],
      "name": "createAccount",
      "outputs": [
        {
          "internalType": "contract Luna",
          "name": "ret",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "proof",
          "type": "bytes"
        },
        {
          "internalType": "address[]",
          "name": "dests",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes[]",
          "name": "funcs",
          "type": "bytes[]"
        }
      ],
      "name": "executeLunaBatchTx",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "proof",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "_recoveryHash",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "email",
          "type": "string"
        }
      ],
      "name": "executeLunaChangeRecovery",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "proof",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_passkeyInput",
          "type": "bytes"
        }
      ],
      "name": "executeLunaPasskeyRecovery",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "proof",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "dest",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "func",
          "type": "bytes"
        }
      ],
      "name": "executeLunaTx",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "_passkeyInputs",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "_recoveryHash",
          "type": "bytes32"
        },
        {
          "internalType": "string",
          "name": "_email",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "salt",
          "type": "uint256"
        }
      ],
      "name": "getAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        }
      ],
      "name": "getLuna",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "walletAddress",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "isUsed",
              "type": "bool"
            }
          ],
          "internalType": "struct LunaStorage.LunaDetails",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "forwarder",
          "type": "address"
        }
      ],
      "name": "isTrustedForwarder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x492589e807b934d2e5a08e7c4e2b54df6591571863c5e29f8a90a4f64d8a7386",
  "receipt": {
    "to": null,
    "from": "0xDb1d125C9f7faE45d7CeE470d048670a85270f4D",
    "contractAddress": "0x0562eefAD05870Dd74dEE7d08a338182eB86De25",
    "transactionIndex": 0,
    "gasUsed": "3414944",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x1960536cd8d1963be7cff29162bae3df90f899397eb1d154c60071bbc3d48663",
    "transactionHash": "0x492589e807b934d2e5a08e7c4e2b54df6591571863c5e29f8a90a4f64d8a7386",
    "logs": [],
    "blockNumber": 2958300,
    "cumulativeGasUsed": "3414944",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xf1E842Ef0774dBE7CaF7f0F95d1315fD834d2a4b",
    "0xbb027482d1F79CeC2AaFA460C428C2A7AE74e970",
    "0x50F1bbb486D62921eD9cE411c6b85Ec0B73D9130"
  ],
  "numDeployments": 2,
  "solcInputHash": "c32d57473aede0cec5c502bb7c7f2b7e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedForwarder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_passkeyVerifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recoveryVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"LUNA_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"contract Luna\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"LunaNameToDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUsed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_passkeyInputs\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_recoveryHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_email\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"contract Luna\",\"name\":\"ret\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"dests\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"funcs\",\"type\":\"bytes[]\"}],\"name\":\"executeLunaBatchTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_recoveryHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"email\",\"type\":\"string\"}],\"name\":\"executeLunaChangeRecovery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_passkeyInput\",\"type\":\"bytes\"}],\"name\":\"executeLunaPasskeyRecovery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"func\",\"type\":\"bytes\"}],\"name\":\"executeLunaTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_passkeyInputs\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_recoveryHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_email\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"getLuna\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUsed\",\"type\":\"bool\"}],\"internalType\":\"struct LunaStorage.LunaDetails\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/LunaFactory.sol\":\"LunaFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC1967.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0x3cbef5ebc24b415252e2f8c0c9254555d30d9f085603b4b80d9b5ed20ab87e90\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/metatx/ERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\nabstract contract ERC2771Context is Context {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable _trustedForwarder;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address trustedForwarder) {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual override returns (address sender) {\\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return super._msgSender();\\n        }\\n    }\\n\\n    function _msgData() internal view virtual override returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return super._msgData();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5e8c266715f6454b732e6c12a85f75dcf3b1c298a90830bb56bfda29fa5b6264\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xa2b22da3032e50b55f95ec1d13336102d675f341167aa76db571ef7f8bb7975d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/IERC1967.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967Upgrade is IERC1967 {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3b21ae06bf5957f73fa16754b0669c77b7abd8ba6c072d35c3281d446fdb86c2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x3d6069be9b4c01fb81840fb9c2c4dc58dd6a6a4aafaa2c6837de8699574d84c6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xeb373f1fdc7b755c6a750123a9b9e3a8a02c1470042fd6505d875000a80bde0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\\n *\\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\\n * contract implement this interface (contract holders can be their own\\n * implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777Recipient {\\n    /**\\n     * @dev Called by an {IERC777} token contract whenever tokens are being\\n     * moved or created into a registered account (`to`). The type of operation\\n     * is conveyed by `from` being the zero address or not.\\n     *\\n     * This call occurs _after_ the token contract's state is updated, so\\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\\n     *\\n     * This function may revert to prevent the operation from being executed.\\n     */\\n    function tokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1a5d61db2733202ba361e6d6741cd2e662380e22b80e987eacfc91973f2267dc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6e00f269073ffc4350e56b7e8153c9092d5f70bfba423299990514183101ef89\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf09e68aa0dc6722a25bc46490e8d48ed864466d17313b8a0b254c36b54e49899\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/Luna.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./callback/TokenCallbackHandler.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nimport \\\"./verifier/PasskeyVerifier.sol\\\";\\nimport \\\"./verifier/RecoveryVerifier.sol\\\";\\n\\nimport \\\"./utils/Conversion.sol\\\";\\n\\ncontract Luna is TokenCallbackHandler, Initializable {\\n\\n    string public DOMAIN;\\n\\n    bytes public passkeyInputs;\\n\\n    bytes32 public recoveryHash;\\n    string public email;\\n\\n    PasskeyUltraVerifier public immutable PASSKEY_VERIFIER;\\n    RecoveryUltraVerifier public immutable RECOVERY_VERIFIER;\\n\\n    uint256 private nonce;\\n\\n    constructor(\\n        address passkeyVerifier_,\\n        address recoveryVerifier_\\n    ) {\\n        PASSKEY_VERIFIER = PasskeyUltraVerifier(passkeyVerifier_);\\n        RECOVERY_VERIFIER = RecoveryUltraVerifier(recoveryVerifier_);\\n    }\\n\\n    function getNonce() public view returns (uint256) {\\n        return nonce;\\n    }\\n\\n    function _useNonce() internal returns (uint256) {\\n        unchecked {\\n            return nonce++;\\n        }\\n    }\\n\\n    function initialize(string memory domain ,bytes memory _passkeyInputs, bytes32 _recoveryHash, string memory _email) external initializer {\\n        _initialize(domain, _passkeyInputs, _recoveryHash, _email);\\n    }\\n\\n    function _initialize(string memory domain, bytes memory _passkeyInputs, bytes32 _recoveryHash, string memory _email) internal virtual {\\n        DOMAIN = domain;\\n        passkeyInputs = _passkeyInputs;\\n        recoveryHash = _recoveryHash;\\n        email = _email;\\n    }\\n\\n    function getCredentialId() public view returns (string memory) {\\n        (, ,string memory credentialId, , , , ) = Conversion.decodeEncodedInputs(passkeyInputs);\\n        return credentialId;\\n    }\\n\\n    function getPublicKey() public view returns (bytes32, bytes32) {\\n        (bytes32 pubkeyx, bytes32 pubkeyy, , , , , ) = Conversion.decodeEncodedInputs(passkeyInputs);\\n        return (pubkeyx, pubkeyy);\\n    }\\n\\n    function getPasskeyMessage() public view returns (bytes32) {\\n        (,,, bytes memory authenticatorData, bytes1 authenticatorDataFlagMask, bytes memory clientData, uint clientChallengeDataOffset) = Conversion.decodeEncodedInputs(passkeyInputs);\\n        return Conversion.computeMessage( authenticatorData, authenticatorDataFlagMask, clientData, Conversion.getPasskeyMessage(getNonce()) , clientChallengeDataOffset);\\n    }\\n\\n    function verifyPasskey(bytes calldata proof) public view returns (bool) {\\n        (bytes32 pubkeyx, bytes32 pubkeyy, , bytes memory authenticatorData, bytes1 authenticatorDataFlagMask, bytes memory clientData, uint clientChallengeDataOffset) = Conversion.decodeEncodedInputs(passkeyInputs);\\n        bytes32 message = Conversion.computeMessage( authenticatorData, authenticatorDataFlagMask, clientData, Conversion.getPasskeyMessage(getNonce()) , clientChallengeDataOffset);\\n\\n\\n        bytes32[] memory inputs = Conversion.convertPasskeyInputs(pubkeyx, pubkeyy, message);\\n        return PASSKEY_VERIFIER.verify(proof, inputs);\\n    }\\n\\n    function usePasskey(bytes calldata proof) internal returns (bool) {\\n        (bytes32 pubkeyx, bytes32 pubkeyy, , bytes memory authenticatorData, bytes1 authenticatorDataFlagMask, bytes memory clientData, uint clientChallengeDataOffset) = Conversion.decodeEncodedInputs(passkeyInputs);\\n        bytes32 message = Conversion.computeMessage( authenticatorData, authenticatorDataFlagMask, clientData, Conversion.getPasskeyMessage(_useNonce()) , clientChallengeDataOffset);\\n\\n\\n        bytes32[] memory inputs = Conversion.convertPasskeyInputs(pubkeyx, pubkeyy, message);\\n        return PASSKEY_VERIFIER.verify(proof, inputs);\\n    }\\n\\n    function verifyRecovery(bytes calldata proof) public view returns (bool) {\\n        bytes32 message = Conversion.hashMessage(Strings.toString(getNonce()));\\n\\n        bytes32[] memory _inputs = Conversion.convertInputs(message, recoveryHash);\\n\\n        return RECOVERY_VERIFIER.verify(proof, _inputs);\\n    }\\n\\n    function useRecovery(bytes calldata proof) internal returns (bool) {\\n        bytes32 message = Conversion.hashMessage(Strings.toString(_useNonce()));\\n\\n        bytes32[] memory _inputs = Conversion.convertInputs(message, recoveryHash);\\n\\n        return RECOVERY_VERIFIER.verify(proof, _inputs);\\n    }\\n\\n    function execute(bytes calldata proof, address dest, uint256 value, bytes calldata func) external payable returns (bool) {\\n        require(usePasskey(proof), \\\"Invalid passkey\\\");\\n        _execute(dest, value, func);\\n        return true;\\n    }\\n\\n    function executeBatch(bytes calldata proof, address[] calldata dest, uint256[] calldata value, bytes[] calldata func) external payable returns (bool) {\\n        require(usePasskey(proof), \\\"Invalid passkey\\\");\\n        _executeBatch(dest, value, func);\\n        return true;\\n    }\\n\\n    function executePasskeyRecovery(bytes calldata proof, bytes memory _passkeyInputs) external payable returns (bool) {\\n        require(useRecovery(proof), \\\"Invalid recovery\\\");\\n        _changePasskeyInputs(_passkeyInputs);\\n        return true;\\n    }\\n\\n    function executeChangeRecovery(bytes calldata proof, bytes32 _recoveryHash, string memory _email) external payable returns (bool) {\\n        require(useRecovery(proof), \\\"Invalid recovery\\\");\\n        _changeRecovery(_recoveryHash, _email);\\n        return true;\\n    }\\n\\n    function _changePasskeyInputs(bytes memory _passkeyInputs) internal  {\\n\\t\\tpasskeyInputs = _passkeyInputs;\\n\\t}\\n\\n    function _changeRecovery(bytes32 _recoveryHash, string memory _email) internal  {\\n        recoveryHash = _recoveryHash;\\n        email = _email;\\n    }\\n\\n    function _execute(address dest, uint256 value, bytes calldata func) internal {\\n        _call(dest, value, func);\\n    }\\n\\n    function _executeBatch(address[] calldata dest, uint256[] calldata value, bytes[] calldata func) internal {\\n        require(dest.length == func.length && (value.length == 0 || value.length == func.length), \\\"wrong array lengths\\\");\\n        if (value.length == 0) {\\n            for (uint256 i = 0; i < dest.length; i++) {\\n                _call(dest[i], 0, func[i]);\\n            }\\n        } else {\\n            for (uint256 i = 0; i < dest.length; i++) {\\n                _call(dest[i], value[i], func[i]);\\n            }\\n        }\\n    }\\n\\n\\tfunction _call(address target, uint256 value, bytes memory data) internal {\\n        (bool success, bytes memory result) = target.call{value : value}(data);\\n        if (!success) {\\n            assembly {\\n                revert(add(result, 32), mload(result))\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n}\",\"keccak256\":\"0x8fcc4ff3884007a09ab6060e9ced0065b81ef8719eac691c090a306f1fc3c3b6\",\"license\":\"MIT\"},\"contracts/LunaFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./Luna.sol\\\";\\nimport \\\"./LunaStorage.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/metatx/ERC2771Context.sol\\\";\\n\\ncontract LunaFactory is LunaStorage, ERC2771Context {\\n    Luna public immutable LUNA_IMPLEMENTATION;\\n\\n    constructor(address _trustedForwarder, address _passkeyVerifier, address _recoveryVerifier) ERC2771Context(_trustedForwarder) {\\n        LUNA_IMPLEMENTATION = new Luna(_passkeyVerifier, _recoveryVerifier);\\n    }\\n\\n    modifier onlyTrustedForwarder() {\\n        require(isTrustedForwarder(msg.sender), \\\"LunaFactory: caller is not the trusted forwarder\\\");\\n        _;\\n    }\\n\\n    function createAccount(string memory name, bytes memory _passkeyInputs, bytes32 _recoveryHash, string memory _email, uint256 salt) external returns (Luna ret) { \\n        if(LunaNameToDetails[name].isUsed) {\\n            ret = Luna(payable(LunaNameToDetails[name].walletAddress));\\n            return ret;\\n        }\\n\\n        address addr = getAddress(name, _passkeyInputs, _recoveryHash, _email, salt);\\n        uint codeSize = addr.code.length;\\n        if (codeSize > 0) {\\n            return Luna(payable(addr));\\n        }\\n        ret = Luna(payable(new ERC1967Proxy{salt : bytes32(salt)}(\\n                address(LUNA_IMPLEMENTATION),\\n                abi.encodeCall(Luna.initialize, (name, _passkeyInputs, _recoveryHash, _email))\\n            )));\\n        addLuna(name, address(ret));\\n    }\\n\\n    function getAddress(string memory name, bytes memory _passkeyInputs, bytes32 _recoveryHash, string memory _email, uint256 salt) public view returns (address) {\\n       return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\\n            type(ERC1967Proxy).creationCode,\\n            abi.encode(\\n                address(LUNA_IMPLEMENTATION),\\n                abi.encodeCall(Luna.initialize, (name, _passkeyInputs, _recoveryHash, _email))\\n            )\\n        )));\\n    }\\n\\n      function executeLunaTx(string memory name, bytes calldata proof, address dest, uint256 value, bytes calldata func) onlyTrustedForwarder isValidLuna(name) external returns (bool) {\\n        Luna luna = Luna(payable(address(LunaNameToDetails[name].walletAddress)));\\n\\n        return luna.execute(proof, dest, value, func);\\n    }\\n\\n    function executeLunaBatchTx(string memory name, bytes calldata proof, address[] calldata dests, uint256[] calldata values, bytes[] calldata funcs) onlyTrustedForwarder isValidLuna(name) external returns (bool) {\\n        Luna luna = Luna(payable(address(LunaNameToDetails[name].walletAddress)));\\n\\n        return luna.executeBatch(proof, dests, values, funcs);\\n    }\\n\\n    function executeLunaPasskeyRecovery(string memory name, bytes calldata proof, bytes memory _passkeyInput) onlyTrustedForwarder isValidLuna(name) external returns (bool) {\\n        Luna luna = Luna(payable(address(LunaNameToDetails[name].walletAddress)));\\n\\n        return luna.executePasskeyRecovery(proof, _passkeyInput);\\n    }\\n\\n    function executeLunaChangeRecovery(string memory name, bytes calldata proof, bytes32 _recoveryHash, string memory email) onlyTrustedForwarder isValidLuna(name) external returns (bool) {\\n        Luna luna = Luna(payable(address(LunaNameToDetails[name].walletAddress)));\\n\\n        return luna.executeChangeRecovery(proof, _recoveryHash, email);\\n    }\\n}\",\"keccak256\":\"0xed0f1c3de81d4c74225301fd436b29228ab6764d3badb061176a3bae4efa0c59\",\"license\":\"MIT\"},\"contracts/LunaStorage.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\ncontract LunaStorage {\\n    \\n    struct LunaDetails {\\n        address walletAddress;\\n        bool isUsed;\\n    }\\n\\n    mapping(string => LunaDetails) public LunaNameToDetails;\\n\\n    function addLuna(string memory name, address walletAddress) internal {\\n        LunaNameToDetails[name] = LunaDetails(walletAddress, true);\\n    }\\n\\n    function _checkLuna(string memory name) internal view {\\n        require(LunaNameToDetails[name].isUsed, \\\"Luna: Invalid Luna\\\");\\n    }\\n    \\n    function getLuna(string memory name) external view returns (LunaDetails memory) {\\n        LunaDetails memory details = LunaNameToDetails[name];\\n        return details;\\n    }\\n\\n    modifier isValidLuna(string memory name) {\\n        _checkLuna(name);\\n        _;\\n    }\\n\\n}\",\"keccak256\":\"0x4e98ccb2f709d18416d546c8e2ce0aee5e41c1c4ed5016970cff338e495af17e\",\"license\":\"MIT\"},\"contracts/callback/TokenCallbackHandler.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-empty-blocks */\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\n\\n/**\\n * Token callback handler.\\n *   Handles supported tokens' callbacks, allowing account receiving these tokens.\\n */\\ncontract TokenCallbackHandler is IERC777Recipient, IERC721Receiver, IERC1155Receiver {\\n    function tokensReceived(\\n        address,\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata,\\n        bytes calldata\\n    ) external pure override {\\n    }\\n\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC1155Receiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IERC721Receiver).interfaceId ||\\n            interfaceId == type(IERC1155Receiver).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId;\\n    }\\n}\",\"keccak256\":\"0x26bd92d845796494079d4231e749bb41b89c4d05e2347affa2c2c80c49e032bf\",\"license\":\"GPL-3.0\"},\"contracts/utils/Conversion.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nlibrary Conversion {\\n    error InvalidAuthenticatorData();\\n    error InvalidClientData();\\n\\n    function convertInputs(bytes32 message, bytes32 _hash) internal pure returns (bytes32 [] memory){\\n        bytes32[] memory byte32Inputs = new bytes32[](33);\\n\\n        for (uint256 i = 0; i < 32; i++) {\\n            byte32Inputs[i] = convertToPaddedByte32(message[i]);\\n        }\\n\\n        byte32Inputs[32] = _hash;\\n\\n        return byte32Inputs;\\n    }\\n\\n    function convertPasskeyInputs(bytes32 pubkeyx, bytes32 pubkeyy, bytes32 message) internal pure returns (bytes32 [] memory){\\n        bytes32[] memory byte32Inputs = new bytes32[](96);\\n\\n        for (uint256 i = 0; i < 32; i++) {\\n            byte32Inputs[i] = convertToPaddedByte32(pubkeyx[i]);\\n            byte32Inputs[i + 32] = convertToPaddedByte32(pubkeyy[i]);\\n            byte32Inputs[i + 64] = convertToPaddedByte32(message[i]);\\n        }\\n\\n        return byte32Inputs;\\n    }\\n\\n    function getPasskeyMessage(uint256 _nonce) internal pure returns (string memory) {\\n        bytes32 hash = sha256(abi.encodePacked(_nonce));\\n        return Strings.toHexString(uint256(hash), 32);\\n    }\\n\\n    function convertToPaddedByte32(bytes32 value) internal pure returns (bytes32) {\\n        bytes32 paddedValue;\\n        paddedValue = bytes32(uint256(value) >> (31 * 8));\\n        return paddedValue;\\n    } \\n\\n    function hashMessage(string memory message) internal pure returns (bytes32) {\\n        string memory messagePrefix = \\\"\\\\x19Ethereum Signed Message:\\\\n\\\";\\n\\n        string memory lengthString = Strings.toString(bytes(message).length);\\n\\n        string memory concatenatedMessage = string(abi.encodePacked(messagePrefix, lengthString, message));\\n\\n        return keccak256(bytes(concatenatedMessage));\\n    }\\n\\n     function decodeEncodedInputs(\\n        bytes memory _inputs\\n    )\\n        internal\\n        pure\\n        returns (bytes32, bytes32, string memory, bytes memory, bytes1, bytes memory, uint)\\n    {\\n        (\\n            bytes32 pubkeyx,\\n            bytes32 pubkeyy,\\n            string memory credentialId,\\n            bytes memory authenticatorData,\\n            bytes1 authenticatorDataFlagMask,\\n            bytes memory clientData,\\n            uint clientChallengeDataOffset\\n        ) = abi.decode(_inputs, (bytes32, bytes32, string, bytes, bytes1, bytes, uint));\\n\\n        return (\\n            pubkeyx,\\n            pubkeyy,\\n            credentialId,\\n            authenticatorData,\\n            authenticatorDataFlagMask,\\n            clientData,\\n            clientChallengeDataOffset\\n        );\\n    }\\n\\n    function computeMessage(\\n        bytes memory authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes memory clientData,\\n        string memory clientChallenge,\\n        uint clientChallengeDataOffset\\n    ) internal pure returns (bytes32) {\\n        if (\\n            (authenticatorData[32] & authenticatorDataFlagMask) !=\\n            authenticatorDataFlagMask\\n        ) {\\n            revert InvalidAuthenticatorData();\\n        }\\n\\n        bytes memory challengeExtracted = new bytes(\\n            bytes(clientChallenge).length\\n        );\\n\\n        copyBytes(\\n            clientData,\\n            clientChallengeDataOffset,\\n            challengeExtracted.length,\\n            challengeExtracted,\\n            0\\n        );\\n\\n        if (\\n            keccak256(abi.encodePacked(bytes(clientChallenge))) !=\\n            keccak256(abi.encodePacked(challengeExtracted))\\n        ) {\\n            revert InvalidClientData();\\n        }\\n\\n        bytes memory verifyData = new bytes(authenticatorData.length + 32);\\n\\n        copyBytes(\\n            authenticatorData,\\n            0,\\n            authenticatorData.length,\\n            verifyData,\\n            0\\n        );\\n\\n        copyBytes(\\n            abi.encodePacked(sha256(clientData)),\\n            0,\\n            32,\\n            verifyData,\\n            authenticatorData.length\\n        );\\n\\n        return (sha256(verifyData));\\n    }\\n\\n    function copyBytes(\\n        bytes memory _from,\\n        uint _fromOffset,\\n        uint _length,\\n        bytes memory _to,\\n        uint _toOffset\\n    ) internal pure returns (bytes memory _copiedBytes) {\\n        uint minLength = _length + _toOffset;\\n        require(_to.length >= minLength);\\n        uint i = 32 + _fromOffset; \\n        uint j = 32 + _toOffset;\\n        while (i < (32 + _fromOffset + _length)) {\\n            assembly {\\n                let tmp := mload(add(_from, i))\\n                mstore(add(_to, j), tmp)\\n            }\\n            i += 32;\\n            j += 32;\\n        }\\n        return _to;\\n    }\\n}\",\"keccak256\":\"0xd4a52a24b5a6e3dcc1868ad2e9f6aaa6313602f15da2e334e9ece83b9ba77f8e\",\"license\":\"MIT\"},\"contracts/verifier/PasskeyVerifier.sol\":{\"content\":\"// Verification Key Hash: 73655a520fe69a4aae4e956ea15dc8c86b5da039b1e389ae53d03cb7a28368bf\\n// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary PasskeyUltraVerificationKey {\\n    function verificationKeyHash() internal pure returns(bytes32) {\\n        return 0x73655a520fe69a4aae4e956ea15dc8c86b5da039b1e389ae53d03cb7a28368bf;\\n    }\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure {\\n        assembly {\\n            mstore(add(_vk, 0x00), 0x0000000000000000000000000000000000000000000000000000000000020000) // vk.circuit_size\\n            mstore(add(_vk, 0x20), 0x0000000000000000000000000000000000000000000000000000000000000060) // vk.num_inputs\\n            mstore(add(_vk, 0x40), 0x1bf82deba7d74902c3708cc6e70e61f30512eca95655210e276e5858ce8f58e5) // vk.work_root\\n            mstore(add(_vk, 0x60), 0x30643640b9f82f90e83b698e5ea6179c7c05542e859533b48b9953a2f5360801) // vk.domain_inverse\\n            mstore(add(_vk, 0x80), 0x21af6847b3024630fd802e6a136c533895fd82c32d4b374785159284a934e75e) // vk.Q1.x\\n            mstore(add(_vk, 0xa0), 0x1f5c461729e56ca865479d1ac9a325619dcfdec29261a9263d07caa272ff345c) // vk.Q1.y\\n            mstore(add(_vk, 0xc0), 0x16e4c481f23bfaa7189c37cd583c1b3c33d153da517f5478586c35271f1ee9d5) // vk.Q2.x\\n            mstore(add(_vk, 0xe0), 0x1fbd75bea6c9aa6ad3925280989f1ae4af666b93d73224c99deb94ab7cf306d8) // vk.Q2.y\\n            mstore(add(_vk, 0x100), 0x0ea07c05ca073f61d9813358d94f23acb09152bfc153ad57a27a8de91c1433c4) // vk.Q3.x\\n            mstore(add(_vk, 0x120), 0x08a2c80abc7885b64e8670a5e1a31b4a2eeec08c86f71c51a203b0ff837fe137) // vk.Q3.y\\n            mstore(add(_vk, 0x140), 0x15a12eb3f7c652238b7e045cd29cbb5745caa141d4514a803986a903184f2214) // vk.Q4.x\\n            mstore(add(_vk, 0x160), 0x1e5dd756f58af2cf877577e25defe2c4266a467474815484363940fc25d163a8) // vk.Q4.y\\n            mstore(add(_vk, 0x180), 0x0e7d51a2f906ae295f4b38dc9a08c92bceb0d998c9a94ae5f47558c57e5f26b4) // vk.Q_M.x\\n            mstore(add(_vk, 0x1a0), 0x2ea47e37339db7a10d8589be0e967bec074f031a4f6f2a3b8d1c7ba1fcd97392) // vk.Q_M.y\\n            mstore(add(_vk, 0x1c0), 0x2301eb485c2666ac8bab5db98d1291b2345acfa80d33dcca337032a88ca21e7c) // vk.Q_C.x\\n            mstore(add(_vk, 0x1e0), 0x13bd260b20b3c74f752b942eb64a8b25dc99f78e2d1a9538dc03cdd7f604c8db) // vk.Q_C.y\\n            mstore(add(_vk, 0x200), 0x137e8298e93fcd681291247d3ea2f9bbff55b098a3cb8483ffad030e4bd768fa) // vk.Q_ARITHMETIC.x\\n            mstore(add(_vk, 0x220), 0x08d160b06b0dc7a93b2b3675273667e8d5f3eb820a028a7a0be703c50f05819f) // vk.Q_ARITHMETIC.y\\n            mstore(add(_vk, 0x240), 0x05031e76776fd6fcf0a513256409568980d7c53706a26b15149b00d909bcf549) // vk.QSORT.x\\n            mstore(add(_vk, 0x260), 0x3032965faac858f7dc048083ee9652d9e4884f21eacdb975709b2165b2ad7ce1) // vk.QSORT.y\\n            mstore(add(_vk, 0x280), 0x28b955aac4c043cbcfde06eee59b44363f96fe0a6fa93b0b36ef07fbe285d4c7) // vk.Q_ELLIPTIC.x\\n            mstore(add(_vk, 0x2a0), 0x16e1bbb0a7728dcb7696fdf3361b39510c6a4f83cc2159f5fc65ceb2be0599f9) // vk.Q_ELLIPTIC.y\\n            mstore(add(_vk, 0x2c0), 0x14b46aa89e437ed7bdf26311f4c04fdfc35178a1f04b81cdaf1b387e4401011c) // vk.Q_AUX.x\\n            mstore(add(_vk, 0x2e0), 0x06be6052a43d9bd21b0b4005c0bc44de2e8c4590d571db5225858defc0a0f58a) // vk.Q_AUX.y\\n            mstore(add(_vk, 0x300), 0x21c223cb2dfb2d5b6456b3598e5d864dcea79f6ef1c8be612e6d5ffe8d8c2777) // vk.SIGMA1.x\\n            mstore(add(_vk, 0x320), 0x2a4d6021070c94b23de18bef63428a3e982e64357c7c8ecad90a22c042369731) // vk.SIGMA1.y\\n            mstore(add(_vk, 0x340), 0x20494b623af3ef4b71e6aaca88a7dbb14436ceca2c6c10444f6c732ea0e6cc18) // vk.SIGMA2.x\\n            mstore(add(_vk, 0x360), 0x027ce1f9dafb05c44b2c360adcb02168c8a43df65e16556c7e0692f6751b7dd3) // vk.SIGMA2.y\\n            mstore(add(_vk, 0x380), 0x05b1166b769248496d2e3754afa52d58d37d19ff33239524b2f61543bce36303) // vk.SIGMA3.x\\n            mstore(add(_vk, 0x3a0), 0x29cf0bfa295e02f24cb5fd969a923bbb4bae606c3b2f706f4ae5fdcfcd257366) // vk.SIGMA3.y\\n            mstore(add(_vk, 0x3c0), 0x1db977d57e7a8c1443606ddf6a88826eb18724ef8fd80a4725887bc259fcfc6a) // vk.SIGMA4.x\\n            mstore(add(_vk, 0x3e0), 0x055843d707abc8456fd76515473c0fa00ef840d4c2827bdf8e99b1579cf49cd7) // vk.SIGMA4.y\\n            mstore(add(_vk, 0x400), 0x28faa42b5c13a5e9927d13e54a2ed806854cd23c6662b320439aa3168beffe03) // vk.TABLE1.x\\n            mstore(add(_vk, 0x420), 0x1e5c18afa66b4c0d19473e0536e64f678c1b094d1b2eff1d7f499dc289efc084) // vk.TABLE1.y\\n            mstore(add(_vk, 0x440), 0x10a001251e9f3a9f283ff8f6bd14cba9c706f3c5040ec8ef10ff44988441251c) // vk.TABLE2.x\\n            mstore(add(_vk, 0x460), 0x12138fab93fce066ddb2f9be4eff97b0fe128a2a2c079f749b8452698cace8bf) // vk.TABLE2.y\\n            mstore(add(_vk, 0x480), 0x133738f359ce2e0f909a0b76a78c602e66e39c41d99f65bfea25f47998283ccd) // vk.TABLE3.x\\n            mstore(add(_vk, 0x4a0), 0x2dd03593caea05125f520c0d02a3bbbdc5519822ba0e0b00984c5a9281143a81) // vk.TABLE3.y\\n            mstore(add(_vk, 0x4c0), 0x09ec9b0aca4e9671903e0577f2a4efd36f7a58af0a5102f5a42e1b8061f62421) // vk.TABLE4.x\\n            mstore(add(_vk, 0x4e0), 0x15affeadf66c8428f4f44d2ebe66e9dc0f04215bef81efbbee166d3f4544feab) // vk.TABLE4.y\\n            mstore(add(_vk, 0x500), 0x1fd912d00da77afb70848e4442324157606f77f54ebc05d1a1a5fc2030836b13) // vk.TABLE_TYPE.x\\n            mstore(add(_vk, 0x520), 0x1b1c85cc22723d352d37c86cfd66d45e809a813b99a452fe452c7ae975de2286) // vk.TABLE_TYPE.y\\n            mstore(add(_vk, 0x540), 0x23c2d50723e2cebb8646048f92426569710fab1c9e8bec7931c8e5ab112ae4ff) // vk.ID1.x\\n            mstore(add(_vk, 0x560), 0x2d8be897c99473f3ad743f9b5aa0ab58ed850738103d1e479ae30387fe48424a) // vk.ID1.y\\n            mstore(add(_vk, 0x580), 0x0e8c8cf6308d7e02f6eff6bb0adbff03e8c1053645365df65d006242da43a876) // vk.ID2.x\\n            mstore(add(_vk, 0x5a0), 0x08366b8f980a58ad8dc1168bd54a8fd3d363d30e3ce0aff8242d30e6fc22ecca) // vk.ID2.y\\n            mstore(add(_vk, 0x5c0), 0x0b199aa2608bab12e8bbf158d4d021514af53a31f069e75c8067150d64721a78) // vk.ID3.x\\n            mstore(add(_vk, 0x5e0), 0x2533df16155cc9efad62b014a13aa5349a80a4a7e9190a6db2bbe7241c00fd09) // vk.ID3.y\\n            mstore(add(_vk, 0x600), 0x0d66ff9b0561e15cb4f5047f54a70ec884f0e95a6217ae980cc0bee78f7f40cf) // vk.ID4.x\\n            mstore(add(_vk, 0x620), 0x2de90d132b5622f75a9ca88e60a9c6f670854a172a025365677a64f627d92412) // vk.ID4.y\\n            mstore(add(_vk, 0x640), 0x00) // vk.contains_recursive_proof\\n            mstore(add(_vk, 0x660), 0) // vk.recursive_proof_public_input_indices\\n            mstore(add(_vk, 0x680), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1 \\n            mstore(add(_vk, 0x6a0), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0 \\n            mstore(add(_vk, 0x6c0), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1 \\n            mstore(add(_vk, 0x6e0), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0 \\n            mstore(_omegaInverseLoc, 0x244cf010c43ca87237d8b00bf9dd50c4c01c7f086bd4e8c920e75251d96f0d22) // vk.work_root_inverse\\n        }\\n    }\\n}\\n/**\\n * @title Ultra Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n */\\nabstract contract PasskeyBaseUltraVerifier {\\n    // VERIFICATION KEY MEMORY LOCATIONS\\n    uint256 internal constant N_LOC = 0x380;\\n    uint256 internal constant NUM_INPUTS_LOC = 0x3a0;\\n    uint256 internal constant OMEGA_LOC = 0x3c0;\\n    uint256 internal constant DOMAIN_INVERSE_LOC = 0x3e0;\\n    uint256 internal constant Q1_X_LOC = 0x400;\\n    uint256 internal constant Q1_Y_LOC = 0x420;\\n    uint256 internal constant Q2_X_LOC = 0x440;\\n    uint256 internal constant Q2_Y_LOC = 0x460;\\n    uint256 internal constant Q3_X_LOC = 0x480;\\n    uint256 internal constant Q3_Y_LOC = 0x4a0;\\n    uint256 internal constant Q4_X_LOC = 0x4c0;\\n    uint256 internal constant Q4_Y_LOC = 0x4e0;\\n    uint256 internal constant QM_X_LOC = 0x500;\\n    uint256 internal constant QM_Y_LOC = 0x520;\\n    uint256 internal constant QC_X_LOC = 0x540;\\n    uint256 internal constant QC_Y_LOC = 0x560;\\n    uint256 internal constant QARITH_X_LOC = 0x580;\\n    uint256 internal constant QARITH_Y_LOC = 0x5a0;\\n    uint256 internal constant QSORT_X_LOC = 0x5c0;\\n    uint256 internal constant QSORT_Y_LOC = 0x5e0;\\n    uint256 internal constant QELLIPTIC_X_LOC = 0x600;\\n    uint256 internal constant QELLIPTIC_Y_LOC = 0x620;\\n    uint256 internal constant QAUX_X_LOC = 0x640;\\n    uint256 internal constant QAUX_Y_LOC = 0x660;\\n    uint256 internal constant SIGMA1_X_LOC = 0x680;\\n    uint256 internal constant SIGMA1_Y_LOC = 0x6a0;\\n    uint256 internal constant SIGMA2_X_LOC = 0x6c0;\\n    uint256 internal constant SIGMA2_Y_LOC = 0x6e0;\\n    uint256 internal constant SIGMA3_X_LOC = 0x700;\\n    uint256 internal constant SIGMA3_Y_LOC = 0x720;\\n    uint256 internal constant SIGMA4_X_LOC = 0x740;\\n    uint256 internal constant SIGMA4_Y_LOC = 0x760;\\n    uint256 internal constant TABLE1_X_LOC = 0x780;\\n    uint256 internal constant TABLE1_Y_LOC = 0x7a0;\\n    uint256 internal constant TABLE2_X_LOC = 0x7c0;\\n    uint256 internal constant TABLE2_Y_LOC = 0x7e0;\\n    uint256 internal constant TABLE3_X_LOC = 0x800;\\n    uint256 internal constant TABLE3_Y_LOC = 0x820;\\n    uint256 internal constant TABLE4_X_LOC = 0x840;\\n    uint256 internal constant TABLE4_Y_LOC = 0x860;\\n    uint256 internal constant TABLE_TYPE_X_LOC = 0x880;\\n    uint256 internal constant TABLE_TYPE_Y_LOC = 0x8a0;\\n    uint256 internal constant ID1_X_LOC = 0x8c0;\\n    uint256 internal constant ID1_Y_LOC = 0x8e0;\\n    uint256 internal constant ID2_X_LOC = 0x900;\\n    uint256 internal constant ID2_Y_LOC = 0x920;\\n    uint256 internal constant ID3_X_LOC = 0x940;\\n    uint256 internal constant ID3_Y_LOC = 0x960;\\n    uint256 internal constant ID4_X_LOC = 0x980;\\n    uint256 internal constant ID4_Y_LOC = 0x9a0;\\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC = 0x9c0;\\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x9e0;\\n    uint256 internal constant G2X_X0_LOC = 0xa00;\\n    uint256 internal constant G2X_X1_LOC = 0xa20;\\n    uint256 internal constant G2X_Y0_LOC = 0xa40;\\n    uint256 internal constant G2X_Y1_LOC = 0xa60;\\n\\n    // ### PROOF DATA MEMORY LOCATIONS\\n    uint256 internal constant W1_X_LOC = 0x1200;\\n    uint256 internal constant W1_Y_LOC = 0x1220;\\n    uint256 internal constant W2_X_LOC = 0x1240;\\n    uint256 internal constant W2_Y_LOC = 0x1260;\\n    uint256 internal constant W3_X_LOC = 0x1280;\\n    uint256 internal constant W3_Y_LOC = 0x12a0;\\n    uint256 internal constant W4_X_LOC = 0x12c0;\\n    uint256 internal constant W4_Y_LOC = 0x12e0;\\n    uint256 internal constant S_X_LOC = 0x1300;\\n    uint256 internal constant S_Y_LOC = 0x1320;\\n    uint256 internal constant Z_X_LOC = 0x1340;\\n    uint256 internal constant Z_Y_LOC = 0x1360;\\n    uint256 internal constant Z_LOOKUP_X_LOC = 0x1380;\\n    uint256 internal constant Z_LOOKUP_Y_LOC = 0x13a0;\\n    uint256 internal constant T1_X_LOC = 0x13c0;\\n    uint256 internal constant T1_Y_LOC = 0x13e0;\\n    uint256 internal constant T2_X_LOC = 0x1400;\\n    uint256 internal constant T2_Y_LOC = 0x1420;\\n    uint256 internal constant T3_X_LOC = 0x1440;\\n    uint256 internal constant T3_Y_LOC = 0x1460;\\n    uint256 internal constant T4_X_LOC = 0x1480;\\n    uint256 internal constant T4_Y_LOC = 0x14a0;\\n\\n    uint256 internal constant W1_EVAL_LOC = 0x1600;\\n    uint256 internal constant W2_EVAL_LOC = 0x1620;\\n    uint256 internal constant W3_EVAL_LOC = 0x1640;\\n    uint256 internal constant W4_EVAL_LOC = 0x1660;\\n    uint256 internal constant S_EVAL_LOC = 0x1680;\\n    uint256 internal constant Z_EVAL_LOC = 0x16a0;\\n    uint256 internal constant Z_LOOKUP_EVAL_LOC = 0x16c0;\\n    uint256 internal constant Q1_EVAL_LOC = 0x16e0;\\n    uint256 internal constant Q2_EVAL_LOC = 0x1700;\\n    uint256 internal constant Q3_EVAL_LOC = 0x1720;\\n    uint256 internal constant Q4_EVAL_LOC = 0x1740;\\n    uint256 internal constant QM_EVAL_LOC = 0x1760;\\n    uint256 internal constant QC_EVAL_LOC = 0x1780;\\n    uint256 internal constant QARITH_EVAL_LOC = 0x17a0;\\n    uint256 internal constant QSORT_EVAL_LOC = 0x17c0;\\n    uint256 internal constant QELLIPTIC_EVAL_LOC = 0x17e0;\\n    uint256 internal constant QAUX_EVAL_LOC = 0x1800;\\n    uint256 internal constant TABLE1_EVAL_LOC = 0x1840;\\n    uint256 internal constant TABLE2_EVAL_LOC = 0x1860;\\n    uint256 internal constant TABLE3_EVAL_LOC = 0x1880;\\n    uint256 internal constant TABLE4_EVAL_LOC = 0x18a0;\\n    uint256 internal constant TABLE_TYPE_EVAL_LOC = 0x18c0;\\n    uint256 internal constant ID1_EVAL_LOC = 0x18e0;\\n    uint256 internal constant ID2_EVAL_LOC = 0x1900;\\n    uint256 internal constant ID3_EVAL_LOC = 0x1920;\\n    uint256 internal constant ID4_EVAL_LOC = 0x1940;\\n    uint256 internal constant SIGMA1_EVAL_LOC = 0x1960;\\n    uint256 internal constant SIGMA2_EVAL_LOC = 0x1980;\\n    uint256 internal constant SIGMA3_EVAL_LOC = 0x19a0;\\n    uint256 internal constant SIGMA4_EVAL_LOC = 0x19c0;\\n    uint256 internal constant W1_OMEGA_EVAL_LOC = 0x19e0;\\n    uint256 internal constant W2_OMEGA_EVAL_LOC = 0x2000;\\n    uint256 internal constant W3_OMEGA_EVAL_LOC = 0x2020;\\n    uint256 internal constant W4_OMEGA_EVAL_LOC = 0x2040;\\n    uint256 internal constant S_OMEGA_EVAL_LOC = 0x2060;\\n    uint256 internal constant Z_OMEGA_EVAL_LOC = 0x2080;\\n    uint256 internal constant Z_LOOKUP_OMEGA_EVAL_LOC = 0x20a0;\\n    uint256 internal constant TABLE1_OMEGA_EVAL_LOC = 0x20c0;\\n    uint256 internal constant TABLE2_OMEGA_EVAL_LOC = 0x20e0;\\n    uint256 internal constant TABLE3_OMEGA_EVAL_LOC = 0x2100;\\n    uint256 internal constant TABLE4_OMEGA_EVAL_LOC = 0x2120;\\n\\n    uint256 internal constant PI_Z_X_LOC = 0x2300;\\n    uint256 internal constant PI_Z_Y_LOC = 0x2320;\\n    uint256 internal constant PI_Z_OMEGA_X_LOC = 0x2340;\\n    uint256 internal constant PI_Z_OMEGA_Y_LOC = 0x2360;\\n\\n    // Used for elliptic widget. These are alias names for wire + shifted wire evaluations\\n    uint256 internal constant X1_EVAL_LOC = W2_EVAL_LOC;\\n    uint256 internal constant X2_EVAL_LOC = W1_OMEGA_EVAL_LOC;\\n    uint256 internal constant X3_EVAL_LOC = W2_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y1_EVAL_LOC = W3_EVAL_LOC;\\n    uint256 internal constant Y2_EVAL_LOC = W4_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y3_EVAL_LOC = W3_OMEGA_EVAL_LOC;\\n    uint256 internal constant QBETA_LOC = Q3_EVAL_LOC;\\n    uint256 internal constant QBETA_SQR_LOC = Q4_EVAL_LOC;\\n    uint256 internal constant QSIGN_LOC = Q1_EVAL_LOC;\\n\\n    // ### CHALLENGES MEMORY OFFSETS\\n\\n    uint256 internal constant C_BETA_LOC = 0x2600;\\n    uint256 internal constant C_GAMMA_LOC = 0x2620;\\n    uint256 internal constant C_ALPHA_LOC = 0x2640;\\n    uint256 internal constant C_ETA_LOC = 0x2660;\\n    uint256 internal constant C_ETA_SQR_LOC = 0x2680;\\n    uint256 internal constant C_ETA_CUBE_LOC = 0x26a0;\\n\\n    uint256 internal constant C_ZETA_LOC = 0x26c0;\\n    uint256 internal constant C_CURRENT_LOC = 0x26e0;\\n    uint256 internal constant C_V0_LOC = 0x2700;\\n    uint256 internal constant C_V1_LOC = 0x2720;\\n    uint256 internal constant C_V2_LOC = 0x2740;\\n    uint256 internal constant C_V3_LOC = 0x2760;\\n    uint256 internal constant C_V4_LOC = 0x2780;\\n    uint256 internal constant C_V5_LOC = 0x27a0;\\n    uint256 internal constant C_V6_LOC = 0x27c0;\\n    uint256 internal constant C_V7_LOC = 0x27e0;\\n    uint256 internal constant C_V8_LOC = 0x2800;\\n    uint256 internal constant C_V9_LOC = 0x2820;\\n    uint256 internal constant C_V10_LOC = 0x2840;\\n    uint256 internal constant C_V11_LOC = 0x2860;\\n    uint256 internal constant C_V12_LOC = 0x2880;\\n    uint256 internal constant C_V13_LOC = 0x28a0;\\n    uint256 internal constant C_V14_LOC = 0x28c0;\\n    uint256 internal constant C_V15_LOC = 0x28e0;\\n    uint256 internal constant C_V16_LOC = 0x2900;\\n    uint256 internal constant C_V17_LOC = 0x2920;\\n    uint256 internal constant C_V18_LOC = 0x2940;\\n    uint256 internal constant C_V19_LOC = 0x2960;\\n    uint256 internal constant C_V20_LOC = 0x2980;\\n    uint256 internal constant C_V21_LOC = 0x29a0;\\n    uint256 internal constant C_V22_LOC = 0x29c0;\\n    uint256 internal constant C_V23_LOC = 0x29e0;\\n    uint256 internal constant C_V24_LOC = 0x2a00;\\n    uint256 internal constant C_V25_LOC = 0x2a20;\\n    uint256 internal constant C_V26_LOC = 0x2a40;\\n    uint256 internal constant C_V27_LOC = 0x2a60;\\n    uint256 internal constant C_V28_LOC = 0x2a80;\\n    uint256 internal constant C_V29_LOC = 0x2aa0;\\n    uint256 internal constant C_V30_LOC = 0x2ac0;\\n\\n    uint256 internal constant C_U_LOC = 0x2b00;\\n\\n    // ### LOCAL VARIABLES MEMORY OFFSETS\\n    uint256 internal constant DELTA_NUMERATOR_LOC = 0x3000;\\n    uint256 internal constant DELTA_DENOMINATOR_LOC = 0x3020;\\n    uint256 internal constant ZETA_POW_N_LOC = 0x3040;\\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC = 0x3060;\\n    uint256 internal constant ZERO_POLY_LOC = 0x3080;\\n    uint256 internal constant L_START_LOC = 0x30a0;\\n    uint256 internal constant L_END_LOC = 0x30c0;\\n    uint256 internal constant R_ZERO_EVAL_LOC = 0x30e0;\\n\\n    uint256 internal constant PLOOKUP_DELTA_NUMERATOR_LOC = 0x3100;\\n    uint256 internal constant PLOOKUP_DELTA_DENOMINATOR_LOC = 0x3120;\\n    uint256 internal constant PLOOKUP_DELTA_LOC = 0x3140;\\n\\n    uint256 internal constant ACCUMULATOR_X_LOC = 0x3160;\\n    uint256 internal constant ACCUMULATOR_Y_LOC = 0x3180;\\n    uint256 internal constant ACCUMULATOR2_X_LOC = 0x31a0;\\n    uint256 internal constant ACCUMULATOR2_Y_LOC = 0x31c0;\\n    uint256 internal constant PAIRING_LHS_X_LOC = 0x31e0;\\n    uint256 internal constant PAIRING_LHS_Y_LOC = 0x3200;\\n    uint256 internal constant PAIRING_RHS_X_LOC = 0x3220;\\n    uint256 internal constant PAIRING_RHS_Y_LOC = 0x3240;\\n\\n    // ### SUCCESS FLAG MEMORY LOCATIONS\\n    uint256 internal constant GRAND_PRODUCT_SUCCESS_FLAG = 0x3300;\\n    uint256 internal constant ARITHMETIC_TERM_SUCCESS_FLAG = 0x3020;\\n    uint256 internal constant BATCH_OPENING_SUCCESS_FLAG = 0x3340;\\n    uint256 internal constant OPENING_COMMITMENT_SUCCESS_FLAG = 0x3360;\\n    uint256 internal constant PAIRING_PREAMBLE_SUCCESS_FLAG = 0x3380;\\n    uint256 internal constant PAIRING_SUCCESS_FLAG = 0x33a0;\\n    uint256 internal constant RESULT_FLAG = 0x33c0;\\n\\n    // misc stuff\\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x3400;\\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x3420;\\n    uint256 internal constant C_ALPHA_CUBE_LOC = 0x3440;\\n    uint256 internal constant C_ALPHA_QUAD_LOC = 0x3460;\\n    uint256 internal constant C_ALPHA_BASE_LOC = 0x3480;\\n\\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x3500;\\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x3520;\\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x3540;\\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x3560;\\n\\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x3580;\\n\\n    // sub-identity storage\\n    uint256 internal constant PERMUTATION_IDENTITY = 0x3600;\\n    uint256 internal constant PLOOKUP_IDENTITY = 0x3620;\\n    uint256 internal constant ARITHMETIC_IDENTITY = 0x3640;\\n    uint256 internal constant SORT_IDENTITY = 0x3660;\\n    uint256 internal constant ELLIPTIC_IDENTITY = 0x3680;\\n    uint256 internal constant AUX_IDENTITY = 0x36a0;\\n    uint256 internal constant AUX_NON_NATIVE_FIELD_EVALUATION = 0x36c0;\\n    uint256 internal constant AUX_LIMB_ACCUMULATOR_EVALUATION = 0x36e0;\\n    uint256 internal constant AUX_RAM_CONSISTENCY_EVALUATION = 0x3700;\\n    uint256 internal constant AUX_ROM_CONSISTENCY_EVALUATION = 0x3720;\\n    uint256 internal constant AUX_MEMORY_EVALUATION = 0x3740;\\n\\n    uint256 internal constant QUOTIENT_EVAL_LOC = 0x3760;\\n    uint256 internal constant ZERO_POLY_INVERSE_LOC = 0x3780;\\n\\n    // when hashing public inputs we use memory at NU_CHALLENGE_INPUT_LOC_A, as the hash input size is unknown at compile time\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_A = 0x37a0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_B = 0x37c0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_C = 0x37e0;\\n\\n    bytes4 internal constant PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR = 0xeba9f4a6;\\n    bytes4 internal constant PUBLIC_INPUT_GE_P_SELECTOR = 0x374a972f;\\n    bytes4 internal constant MOD_EXP_FAILURE_SELECTOR = 0xf894a7bc;\\n    bytes4 internal constant EC_SCALAR_MUL_FAILURE_SELECTOR = 0xf755f369;\\n    bytes4 internal constant PROOF_FAILURE_SELECTOR = 0x0711fcec;\\n\\n    uint256 internal constant ETA_INPUT_LENGTH = 0xc0; // W1, W2, W3 = 6 * 0x20 bytes\\n\\n    // We need to hash 41 field elements when generating the NU challenge\\n    // w1, w2, w3, w4, s, z, z_lookup, q1, q2, q3, q4, qm, qc, qarith (14)\\n    // qsort, qelliptic, qaux, sigma1, sigma2, sigma, sigma4, (7)\\n    // table1, table2, table3, table4, tabletype, id1, id2, id3, id4, (9)\\n    // w1_omega, w2_omega, w3_omega, w4_omega, s_omega, z_omega, z_lookup_omega, (7)\\n    // table1_omega, table2_omega, table3_omega, table4_omega (4)\\n    uint256 internal constant NU_INPUT_LENGTH = 0x520; // 0x520 = 41 * 0x20\\n\\n    // There are ELEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n    // W1, W2, W3, W4, S, Z, Z_LOOKUP, T1, T2, T3, T4\\n    uint256 internal constant NU_CALLDATA_SKIP_LENGTH = 0x2c0; // 11 * 0x40 = 0x2c0\\n\\n    uint256 internal constant NEGATIVE_INVERSE_OF_2_MODULO_P =\\n        0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    uint256 internal constant LIMB_SIZE = 0x100000000000000000; // 2<<68\\n    uint256 internal constant SUBLIMB_SHIFT = 0x4000; // 2<<14\\n\\n    // y^2 = x^3 + ax + b\\n    // for Grumpkin, a = 0 and b = -17. We use b in a custom gate relation that evaluates elliptic curve arithmetic\\n    uint256 internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = 17;\\n    error PUBLIC_INPUT_COUNT_INVALID(uint256 expected, uint256 actual);\\n    error PUBLIC_INPUT_INVALID_BN128_G1_POINT();\\n    error PUBLIC_INPUT_GE_P();\\n    error MOD_EXP_FAILURE();\\n    error EC_SCALAR_MUL_FAILURE();\\n    error PROOF_FAILURE();\\n\\n    function getVerificationKeyHash() public pure virtual returns (bytes32);\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure virtual;\\n\\n    /**\\n     * @notice Verify a Ultra Plonk proof\\n     * @param _proof - The serialized proof\\n     * @param _publicInputs - An array of the public inputs\\n     * @return True if proof is valid, reverts otherwise\\n     */\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool) {\\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\\n\\n        uint256 requiredPublicInputCount;\\n        assembly {\\n            requiredPublicInputCount := mload(NUM_INPUTS_LOC)\\n        }\\n        if (requiredPublicInputCount != _publicInputs.length) {\\n            revert PUBLIC_INPUT_COUNT_INVALID(requiredPublicInputCount, _publicInputs.length);\\n        }\\n\\n        assembly {\\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\\n\\n            /**\\n             * LOAD PROOF FROM CALLDATA\\n             */\\n            {\\n                let data_ptr := add(calldataload(0x04), 0x24)\\n\\n                mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\\n                mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\\n\\n                mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\\n                mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\\n\\n                mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\\n                mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\\n\\n                mstore(W4_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\\n                mstore(W4_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\\n\\n                mstore(S_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\\n                mstore(S_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\\n                mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\\n                mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\\n                mstore(Z_LOOKUP_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\\n                mstore(Z_LOOKUP_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\\n                mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x1c0)), q))\\n                mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x1e0)), q))\\n\\n                mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x200)), q))\\n                mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x220)), q))\\n\\n                mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x240)), q))\\n                mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x260)), q))\\n\\n                mstore(T4_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\\n                mstore(T4_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\\n\\n                mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2c0)), p))\\n                mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2e0)), p))\\n                mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x300)), p))\\n                mstore(W4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x320)), p))\\n                mstore(S_EVAL_LOC, mod(calldataload(add(data_ptr, 0x340)), p))\\n                mstore(Z_EVAL_LOC, mod(calldataload(add(data_ptr, 0x360)), p))\\n                mstore(Z_LOOKUP_EVAL_LOC, mod(calldataload(add(data_ptr, 0x380)), p))\\n                mstore(Q1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3a0)), p))\\n                mstore(Q2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3c0)), p))\\n                mstore(Q3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3e0)), p))\\n                mstore(Q4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x400)), p))\\n                mstore(QM_EVAL_LOC, mod(calldataload(add(data_ptr, 0x420)), p))\\n                mstore(QC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x440)), p))\\n                mstore(QARITH_EVAL_LOC, mod(calldataload(add(data_ptr, 0x460)), p))\\n                mstore(QSORT_EVAL_LOC, mod(calldataload(add(data_ptr, 0x480)), p))\\n                mstore(QELLIPTIC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4a0)), p))\\n                mstore(QAUX_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4c0)), p))\\n\\n                mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4e0)), p))\\n                mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x500)), p))\\n\\n                mstore(SIGMA3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x520)), p))\\n                mstore(SIGMA4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x540)), p))\\n\\n                mstore(TABLE1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x560)), p))\\n                mstore(TABLE2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x580)), p))\\n                mstore(TABLE3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5a0)), p))\\n                mstore(TABLE4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5c0)), p))\\n                mstore(TABLE_TYPE_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5e0)), p))\\n\\n                mstore(ID1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x600)), p))\\n                mstore(ID2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x620)), p))\\n                mstore(ID3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x640)), p))\\n                mstore(ID4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x660)), p))\\n\\n                mstore(W1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x680)), p))\\n                mstore(W2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6a0)), p))\\n                mstore(W3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6c0)), p))\\n                mstore(W4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6e0)), p))\\n                mstore(S_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x700)), p))\\n\\n                mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x720)), p))\\n\\n                mstore(Z_LOOKUP_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x740)), p))\\n                mstore(TABLE1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x760)), p))\\n                mstore(TABLE2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x780)), p))\\n                mstore(TABLE3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7a0)), p))\\n                mstore(TABLE4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7c0)), p))\\n\\n                mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x7e0)), q))\\n                mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x800)), q))\\n\\n                mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x820)), q))\\n                mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x840)), q))\\n            }\\n\\n            /**\\n             * LOAD RECURSIVE PROOF INTO MEMORY\\n             */\\n            {\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n                    let index_counter := add(shl(5, mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC)), public_inputs_ptr)\\n\\n                    let x0 := calldataload(index_counter)\\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                    let y0 := calldataload(add(index_counter, 0x80))\\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                    let x1 := calldataload(add(index_counter, 0x100))\\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                    let y1 := calldataload(add(index_counter, 0x180))\\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n                    mstore(RECURSIVE_P1_X_LOC, x0)\\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\\n                    mstore(RECURSIVE_P2_X_LOC, x1)\\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\\n\\n                    // validate these are valid bn128 G1 points\\n                    if iszero(and(and(lt(x0, q), lt(x1, q)), and(lt(y0, q), lt(y1, q)))) {\\n                        mstore(0x00, PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * Generate initial challenge\\n                 */\\n                mstore(0x00, shl(224, mload(N_LOC)))\\n                mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\\n                let challenge := keccak256(0x00, 0x08)\\n\\n                /**\\n                 * Generate eta challenge\\n                 */\\n                mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\\n                // The public input location is stored at 0x24, we then add 0x24 to skip selector and the length of public inputs\\n                let public_inputs_start := add(calldataload(0x24), 0x24)\\n                // copy the public inputs over\\n                let public_input_size := mul(mload(NUM_INPUTS_LOC), 0x20)\\n                calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_inputs_start, public_input_size)\\n\\n                // copy W1, W2, W3 into challenge. Each point is 0x40 bytes, so load 0xc0 = 3 * 0x40 bytes (ETA input length)\\n                let w_start := add(calldataload(0x04), 0x24)\\n                calldatacopy(add(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_input_size), w_start, ETA_INPUT_LENGTH)\\n\\n                // Challenge is the old challenge + public inputs + W1, W2, W3 (0x20 + public_input_size + 0xc0)\\n                let challenge_bytes_size := add(0x20, add(public_input_size, ETA_INPUT_LENGTH))\\n\\n                challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, challenge_bytes_size)\\n                {\\n                    let eta := mod(challenge, p)\\n                    mstore(C_ETA_LOC, eta)\\n                    mstore(C_ETA_SQR_LOC, mulmod(eta, eta, p))\\n                    mstore(C_ETA_CUBE_LOC, mulmod(mload(C_ETA_SQR_LOC), eta, p))\\n                }\\n\\n                /**\\n                 * Generate beta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(W4_Y_LOC))\\n                mstore(0x40, mload(W4_X_LOC))\\n                mstore(0x60, mload(S_Y_LOC))\\n                mstore(0x80, mload(S_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_BETA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate gamma challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_GAMMA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate alpha challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(Z_Y_LOC))\\n                mstore(0x40, mload(Z_X_LOC))\\n                mstore(0x60, mload(Z_LOOKUP_Y_LOC))\\n                mstore(0x80, mload(Z_LOOKUP_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_ALPHA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Compute and store some powers of alpha for future computations\\n                 */\\n                let alpha := mload(C_ALPHA_LOC)\\n                mstore(C_ALPHA_SQR_LOC, mulmod(alpha, alpha, p))\\n                mstore(C_ALPHA_CUBE_LOC, mulmod(mload(C_ALPHA_SQR_LOC), alpha, p))\\n                mstore(C_ALPHA_QUAD_LOC, mulmod(mload(C_ALPHA_CUBE_LOC), alpha, p))\\n                mstore(C_ALPHA_BASE_LOC, alpha)\\n\\n                /**\\n                 * Generate zeta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(T1_Y_LOC))\\n                mstore(0x40, mload(T1_X_LOC))\\n                mstore(0x60, mload(T2_Y_LOC))\\n                mstore(0x80, mload(T2_X_LOC))\\n                mstore(0xa0, mload(T3_Y_LOC))\\n                mstore(0xc0, mload(T3_X_LOC))\\n                mstore(0xe0, mload(T4_Y_LOC))\\n                mstore(0x100, mload(T4_X_LOC))\\n\\n                challenge := keccak256(0x00, 0x120)\\n\\n                mstore(C_ZETA_LOC, mod(challenge, p))\\n                mstore(C_CURRENT_LOC, challenge)\\n            }\\n\\n            /**\\n             * EVALUATE FIELD OPERATIONS\\n             */\\n\\n            /**\\n             * COMPUTE PUBLIC INPUT DELTA\\n             * \\u0394PI = \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3(i) + \\u03b3) / \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3'(i) + \\u03b3)\\n             */\\n            {\\n                let beta := mload(C_BETA_LOC) // \\u03b2\\n                let gamma := mload(C_GAMMA_LOC) // \\u03b3\\n                let work_root := mload(OMEGA_LOC) // \\u03c9\\n                let numerator_value := 1\\n                let denominator_value := 1\\n\\n                let p_clone := p // move p to the front of the stack\\n                let valid_inputs := true\\n\\n                // Load the starting point of the public inputs (jump over the selector and the length of public inputs [0x24])\\n                let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n\\n                // endpoint_ptr = public_inputs_ptr + num_inputs * 0x20. // every public input is 0x20 bytes\\n                let endpoint_ptr := add(public_inputs_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\\n\\n                // root_1 = \\u03b2 * 0x05\\n                let root_1 := mulmod(beta, 0x05, p_clone) // k1.\\u03b2\\n                // root_2 = \\u03b2 * 0x0c\\n                let root_2 := mulmod(beta, 0x0c, p_clone)\\n                // @note 0x05 + 0x07 == 0x0c == external coset generator\\n\\n                for {} lt(public_inputs_ptr, endpoint_ptr) { public_inputs_ptr := add(public_inputs_ptr, 0x20) } {\\n                    /**\\n                     * input = public_input[i]\\n                     * valid_inputs &= input < p\\n                     * temp = input + gamma\\n                     * numerator_value *= (\\u03b2.\\u03c3(i) + w\\u1d62 + \\u03b3)  // \\u03c3(i) = 0x05.\\u03c9\\u2071\\n                     * denominator_value *= (\\u03b2.\\u03c3'(i) + w\\u1d62 + \\u03b3) // \\u03c3'(i) = 0x0c.\\u03c9\\u2071\\n                     * root_1 *= \\u03c9\\n                     * root_2 *= \\u03c9\\n                     */\\n\\n                    let input := calldataload(public_inputs_ptr)\\n                    valid_inputs := and(valid_inputs, lt(input, p_clone))\\n                    let temp := addmod(input, gamma, p_clone)\\n\\n                    numerator_value := mulmod(numerator_value, add(root_1, temp), p_clone)\\n                    denominator_value := mulmod(denominator_value, add(root_2, temp), p_clone)\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n                }\\n\\n                // Revert if not all public inputs are field elements (i.e. < p)\\n                if iszero(valid_inputs) {\\n                    mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n\\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\\n            }\\n\\n            /**\\n             * Compute Plookup delta factor [\\u03b3(1 + \\u03b2)]^{n-k}\\n             * k = num roots cut out of Z_H = 4\\n             */\\n            {\\n                let delta_base := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let delta_numerator := delta_base\\n                {\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        delta_numerator := mulmod(delta_numerator, delta_numerator, p)\\n                    }\\n                }\\n                mstore(PLOOKUP_DELTA_NUMERATOR_LOC, delta_numerator)\\n\\n                let delta_denominator := mulmod(delta_base, delta_base, p)\\n                delta_denominator := mulmod(delta_denominator, delta_denominator, p)\\n                mstore(PLOOKUP_DELTA_DENOMINATOR_LOC, delta_denominator)\\n            }\\n            /**\\n             * Compute lagrange poly and vanishing poly fractions\\n             */\\n            {\\n                /**\\n                 * vanishing_numerator = zeta\\n                 * ZETA_POW_N = zeta^n\\n                 * vanishing_numerator -= 1\\n                 * accumulating_root = omega_inverse\\n                 * work_root = p - accumulating_root\\n                 * domain_inverse = domain_inverse\\n                 * vanishing_denominator = zeta + work_root\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * vanishing_denominator *= (zeta + (zeta + accumulating_root))\\n                 * work_root = omega\\n                 * lagrange_numerator = vanishing_numerator * domain_inverse\\n                 * l_start_denominator = zeta - 1\\n                 * accumulating_root = work_root^2\\n                 * l_end_denominator = accumulating_root^2 * work_root * zeta - 1\\n                 * Note: l_end_denominator term contains a term \\\\omega^5 to cut out 5 roots of unity from vanishing poly\\n                 */\\n\\n                let zeta := mload(C_ZETA_LOC)\\n\\n                // compute zeta^n, where n is a power of 2\\n                let vanishing_numerator := zeta\\n                {\\n                    // pow_small\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\\n                    }\\n                }\\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n\\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\\n                let work_root := sub(p, accumulating_root)\\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\\n\\n                let vanishing_denominator := addmod(zeta, work_root, p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                vanishing_denominator :=\\n                    mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\\n\\n                work_root := mload(OMEGA_LOC)\\n\\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\\n\\n                accumulating_root := mulmod(work_root, work_root, p)\\n\\n                let l_end_denominator :=\\n                    addmod(\\n                        mulmod(mulmod(mulmod(accumulating_root, accumulating_root, p), work_root, p), zeta, p), sub(p, 1), p\\n                    )\\n\\n                /**\\n                 * Compute inversions using Montgomery's batch inversion trick\\n                 */\\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\\n                let t0 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n                let t1 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n                let t2 := accumulator\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n                let t3 := accumulator\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n                let t4 := accumulator\\n                {\\n                    mstore(0, 0x20)\\n                    mstore(0x20, 0x20)\\n                    mstore(0x40, 0x20)\\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\\n                    mstore(0x80, sub(p, 2))\\n                    mstore(0xa0, p)\\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20)) {\\n                        mstore(0x0, MOD_EXP_FAILURE_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                    accumulator := mload(0x00)\\n                }\\n\\n                t4 := mulmod(accumulator, t4, p)\\n                accumulator := mulmod(accumulator, l_end_denominator, p)\\n\\n                t3 := mulmod(accumulator, t3, p)\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n\\n                t2 := mulmod(accumulator, t2, p)\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n\\n                t1 := mulmod(accumulator, t1, p)\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n\\n                t0 := mulmod(accumulator, t0, p)\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n\\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\\n\\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\\n                mstore(ZERO_POLY_INVERSE_LOC, mulmod(vanishing_denominator, t1, p))\\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t2, p))\\n                mstore(PLOOKUP_DELTA_LOC, mulmod(mload(PLOOKUP_DELTA_NUMERATOR_LOC), t3, p))\\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t4, p))\\n            }\\n\\n            /**\\n             * UltraPlonk Widget Ordering:\\n             *\\n             * 1. Permutation widget\\n             * 2. Plookup widget\\n             * 3. Arithmetic widget\\n             * 4. Fixed base widget (?)\\n             * 5. GenPermSort widget\\n             * 6. Elliptic widget\\n             * 7. Auxiliary widget\\n             */\\n\\n            /**\\n             * COMPUTE PERMUTATION WIDGET EVALUATION\\n             */\\n            {\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta := mload(C_BETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n\\n                /**\\n                 * t1 = (W1 + gamma + beta * ID1) * (W2 + gamma + beta * ID2)\\n                 * t2 = (W3 + gamma + beta * ID3) * (W4 + gamma + beta * ID4)\\n                 * result = alpha_base * z_eval * t1 * t2\\n                 * t1 = (W1 + gamma + beta * sigma_1_eval) * (W2 + gamma + beta * sigma_2_eval)\\n                 * t2 = (W2 + gamma + beta * sigma_3_eval) * (W3 + gamma + beta * sigma_4_eval)\\n                 * result -= (alpha_base * z_omega_eval * t1 * t2)\\n                 */\\n                let t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(ID1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(ID2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(ID3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(ID4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let result := mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_EVAL_LOC), mulmod(t1, t2, p), p), p)\\n                t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                result :=\\n                    addmod(\\n                        result,\\n                        sub(p, mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_OMEGA_EVAL_LOC), mulmod(t1, t2, p), p), p)),\\n                        p\\n                    )\\n\\n                /**\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_{n-k}(\\u0293) . (z(\\u0293.\\u03c9) - \\u2206_{PI}))\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_1(\\u0293)(Z(\\u0293) - 1))\\n                 * alpha_Base *= alpha\\n                 */\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                result :=\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(\\n                                mload(L_END_LOC),\\n                                addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                mstore(\\n                    PERMUTATION_IDENTITY,\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(mload(L_START_LOC), addmod(mload(Z_EVAL_LOC), sub(p, 1), p), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE PLOOKUP WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * Goal: f = (w1(z) + q2.w1(z\\u03c9)) + \\u03b7(w2(z) + qm.w2(z\\u03c9)) + \\u03b7\\u00b2(w3(z) + qc.w_3(z\\u03c9)) + q3(z).\\u03b7\\u00b3\\n                 * f = \\u03b7.q3(z)\\n                 * f += (w3(z) + qc.w_3(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w2(z) + qm.w2(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w1(z) + q2.w1(z\\u03c9))\\n                 */\\n                let f := mulmod(mload(C_ETA_LOC), mload(Q3_EVAL_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W3_EVAL_LOC), mulmod(mload(QC_EVAL_LOC), mload(W3_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W2_EVAL_LOC), mulmod(mload(QM_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W1_EVAL_LOC), mulmod(mload(Q2_EVAL_LOC), mload(W1_OMEGA_EVAL_LOC), p), p), p)\\n\\n                // t(z) = table4(z).\\u03b7\\u00b3 + table3(z).\\u03b7\\u00b2 + table2(z).\\u03b7 + table1(z)\\n                let t :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_EVAL_LOC),\\n                        p\\n                    )\\n\\n                // t(zw) = table4(zw).\\u03b7\\u00b3 + table3(zw).\\u03b7\\u00b2 + table2(zw).\\u03b7 + table1(zw)\\n                let t_omega :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_OMEGA_EVAL_LOC),\\n                        p\\n                    )\\n\\n                /**\\n                 * Goal: numerator = (TABLE_TYPE_EVAL * f(z) + \\u03b3) * (t(z) + \\u03b2t(z\\u03c9) + \\u03b3(\\u03b2 + 1)) * (\\u03b2 + 1)\\n                 * gamma_beta_constant = \\u03b3(\\u03b2 + 1)\\n                 * numerator = f * TABLE_TYPE_EVAL + gamma\\n                 * temp0 = t(z) + t(z\\u03c9) * \\u03b2 + gamma_beta_constant\\n                 * numerator *= temp0\\n                 * numerator *= (\\u03b2 + 1)\\n                 * temp0 = alpha * l_1\\n                 * numerator += temp0\\n                 * numerator *= z_lookup(z)\\n                 * numerator -= temp0\\n                 */\\n                let gamma_beta_constant := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let numerator := addmod(mulmod(f, mload(TABLE_TYPE_EVAL_LOC), p), mload(C_GAMMA_LOC), p)\\n                let temp0 := addmod(addmod(t, mulmod(t_omega, mload(C_BETA_LOC), p), p), gamma_beta_constant, p)\\n                numerator := mulmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, addmod(mload(C_BETA_LOC), 1, p), p)\\n                temp0 := mulmod(mload(C_ALPHA_LOC), mload(L_START_LOC), p)\\n                numerator := addmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, mload(Z_LOOKUP_EVAL_LOC), p)\\n                numerator := addmod(numerator, sub(p, temp0), p)\\n\\n                /**\\n                 * Goal: denominator = z_lookup(z\\u03c9)*[s(z) + \\u03b2s(z\\u03c9) + \\u03b3(1 + \\u03b2)] - [z_lookup(z\\u03c9) - [\\u03b3(1 + \\u03b2)]^{n-k}]*\\u03b1\\u00b2L_end(z)\\n                 * note: delta_factor = [\\u03b3(1 + \\u03b2)]^{n-k}\\n                 * denominator = s(z) + \\u03b2s(z\\u03c9) + \\u03b3(\\u03b2 + 1)\\n                 * temp1 = \\u03b1\\u00b2L_end(z)\\n                 * denominator -= temp1\\n                 * denominator *= z_lookup(z\\u03c9)\\n                 * denominator += temp1 * delta_factor\\n                 * PLOOKUP_IDENTITY = (numerator - denominator).alpha_base\\n                 * alpha_base *= alpha^3\\n                 */\\n                let denominator :=\\n                    addmod(\\n                        addmod(mload(S_EVAL_LOC), mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_BETA_LOC), p), p),\\n                        gamma_beta_constant,\\n                        p\\n                    )\\n                let temp1 := mulmod(mload(C_ALPHA_SQR_LOC), mload(L_END_LOC), p)\\n                denominator := addmod(denominator, sub(p, temp1), p)\\n                denominator := mulmod(denominator, mload(Z_LOOKUP_OMEGA_EVAL_LOC), p)\\n                denominator := addmod(denominator, mulmod(temp1, mload(PLOOKUP_DELTA_LOC), p), p)\\n\\n                mstore(PLOOKUP_IDENTITY, mulmod(addmod(numerator, sub(p, denominator), p), mload(C_ALPHA_BASE_LOC), p))\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ARITHMETIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * The basic arithmetic gate identity in standard plonk is as follows.\\n                 * (w_1 . w_2 . q_m) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c = 0\\n                 * However, for Ultraplonk, we extend this to support \\\"passing\\\" wires between rows (shown without alpha scaling below):\\n                 * q_arith * ( ( (-1/2) * (q_arith - 3) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c ) +\\n                 * (q_arith - 1)*( \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m) + w_4_omega) ) = 0\\n                 *\\n                 * This formula results in several cases depending on q_arith:\\n                 * 1. q_arith == 0: Arithmetic gate is completely disabled\\n                 *\\n                 * 2. q_arith == 1: Everything in the minigate on the right is disabled. The equation is just a standard plonk equation\\n                 * with extra wires: q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c = 0\\n                 *\\n                 * 3. q_arith == 2: The (w_1 + w_4 - ...) term is disabled. THe equation is:\\n                 * (1/2) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + w_4_omega = 0\\n                 * It allows defining w_4 at next index (w_4_omega) in terms of current wire values\\n                 *\\n                 * 4. q_arith == 3: The product of w_1 and w_2 is disabled, but a mini addition gate is enabled. \\u03b1 allows us to split\\n                 * the equation into two:\\n                 *\\n                 * q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + 2 * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0  (we are reusing q_m here)\\n                 *\\n                 * 5. q_arith > 3: The product of w_1 and w_2 is scaled by (q_arith - 3), while the w_4_omega term is scaled by (q_arith - 1).\\n                 * The equation can be split into two:\\n                 *\\n                 * (q_arith - 3)* q_m * w_1 * w_ 2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + (q_arith - 1) * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0\\n                 *\\n                 * The problem that q_m is used both in both equations can be dealt with by appropriately changing selector values at\\n                 * the next gate. Then we can treat (q_arith - 1) as a simulated q_6 selector and scale q_m to handle (q_arith - 3) at\\n                 * product.\\n                 */\\n\\n                let w1q1 := mulmod(mload(W1_EVAL_LOC), mload(Q1_EVAL_LOC), p)\\n                let w2q2 := mulmod(mload(W2_EVAL_LOC), mload(Q2_EVAL_LOC), p)\\n                let w3q3 := mulmod(mload(W3_EVAL_LOC), mload(Q3_EVAL_LOC), p)\\n                let w4q3 := mulmod(mload(W4_EVAL_LOC), mload(Q4_EVAL_LOC), p)\\n\\n                // @todo - Add a explicit test that hits QARITH == 3\\n                // w1w2qm := (w_1 . w_2 . q_m . (QARITH_EVAL_LOC - 3)) / 2\\n                let w1w2qm :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(mulmod(mload(W1_EVAL_LOC), mload(W2_EVAL_LOC), p), mload(QM_EVAL_LOC), p),\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 3), p),\\n                            p\\n                        ),\\n                        NEGATIVE_INVERSE_OF_2_MODULO_P,\\n                        p\\n                    )\\n\\n                // (w_1 . w_2 . q_m . (q_arith - 3)) / -2) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c\\n                let identity :=\\n                    addmod(\\n                        mload(QC_EVAL_LOC), addmod(w4q3, addmod(w3q3, addmod(w2q2, addmod(w1q1, w1w2qm, p), p), p), p), p\\n                    )\\n\\n                // if q_arith == 3 we evaluate an additional mini addition gate (on top of the regular one), where:\\n                // w_1 + w_4 - w_1_omega + q_m = 0\\n                // we use this gate to save an addition gate when adding or subtracting non-native field elements\\n                // \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m)\\n                let extra_small_addition_gate_identity :=\\n                    mulmod(\\n                        mload(C_ALPHA_LOC),\\n                        mulmod(\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 2), p),\\n                            addmod(\\n                                mload(QM_EVAL_LOC),\\n                                addmod(\\n                                    sub(p, mload(W1_OMEGA_EVAL_LOC)), addmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p), p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                // if q_arith == 2 OR q_arith == 3 we add the 4th wire of the NEXT gate into the arithmetic identity\\n                // N.B. if q_arith > 2, this wire value will be scaled by (q_arith - 1) relative to the other gate wires!\\n                // alpha_base * q_arith * (identity + (q_arith - 1) * (w_4_omega + extra_small_addition_gate_identity))\\n                mstore(\\n                    ARITHMETIC_IDENTITY,\\n                    mulmod(\\n                        mload(C_ALPHA_BASE_LOC),\\n                        mulmod(\\n                            mload(QARITH_EVAL_LOC),\\n                            addmod(\\n                                identity,\\n                                mulmod(\\n                                    addmod(mload(QARITH_EVAL_LOC), sub(p, 1), p),\\n                                    addmod(mload(W4_OMEGA_EVAL_LOC), extra_small_addition_gate_identity, p),\\n                                    p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE GENPERMSORT WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * D1 = (w2 - w1)\\n                 * D2 = (w3 - w2)\\n                 * D3 = (w4 - w3)\\n                 * D4 = (w1_omega - w4)\\n                 *\\n                 * \\u03b1_a = alpha_base\\n                 * \\u03b1_b = alpha_base * \\u03b1\\n                 * \\u03b1_c = alpha_base * \\u03b1^2\\n                 * \\u03b1_d = alpha_base * \\u03b1^3\\n                 *\\n                 * range_accumulator = (\\n                 *   D1(D1 - 1)(D1 - 2)(D1 - 3).\\u03b1_a +\\n                 *   D2(D2 - 1)(D2 - 2)(D2 - 3).\\u03b1_b +\\n                 *   D3(D3 - 1)(D3 - 2)(D3 - 3).\\u03b1_c +\\n                 *   D4(D4 - 1)(D4 - 2)(D4 - 3).\\u03b1_d +\\n                 * ) . q_sort\\n                 */\\n                let minus_two := sub(p, 2)\\n                let minus_three := sub(p, 3)\\n                let d1 := addmod(mload(W2_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                let d2 := addmod(mload(W3_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n                let d3 := addmod(mload(W4_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                let d4 := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                let range_accumulator :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(addmod(mulmod(d1, d1, p), sub(p, d1), p), addmod(d1, minus_two, p), p),\\n                            addmod(d1, minus_three, p),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d2, d2, p), sub(p, d2), p), addmod(d2, minus_two, p), p),\\n                                addmod(d2, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d3, d3, p), sub(p, d3), p), addmod(d3, minus_two, p), p),\\n                                addmod(d3, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d4, d4, p), sub(p, d4), p), addmod(d4, minus_two, p), p),\\n                                addmod(d4, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator := mulmod(range_accumulator, mload(QSORT_EVAL_LOC), p)\\n\\n                mstore(SORT_IDENTITY, range_accumulator)\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ELLIPTIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * endo_term = (-x_2) * x_1 * (x_3 * 2 + x_1) * q_beta\\n                 * endo_sqr_term = x_2^2\\n                 * endo_sqr_term *= (x_3 - x_1)\\n                 * endo_sqr_term *= q_beta^2\\n                 * leftovers = x_2^2\\n                 * leftovers *= x_2\\n                 * leftovers += x_1^2 * (x_3 + x_1) @follow-up Invalid comment in BB widget\\n                 * leftovers -= (y_2^2 + y_1^2)\\n                 * sign_term = y_2 * y_1\\n                 * sign_term += sign_term\\n                 * sign_term *= q_sign\\n                 */\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let x_diff := addmod(mload(X2_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p)\\n                let y2_sqr := mulmod(mload(Y2_EVAL_LOC), mload(Y2_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let y1y2 := mulmod(mulmod(mload(Y1_EVAL_LOC), mload(Y2_EVAL_LOC), p), mload(QSIGN_LOC), p)\\n\\n                let x_add_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X2_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            mulmod(x_diff, x_diff, p),\\n                            p\\n                        ),\\n                        addmod(\\n                            sub(\\n                                p,\\n                                addmod(y2_sqr, y1_sqr, p)\\n                            ),\\n                            addmod(y1y2, y1y2, p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                x_add_identity :=\\n                    mulmod(\\n                        mulmod(\\n                            x_add_identity,\\n                            addmod(\\n                                1,\\n                                sub(p, mload(QM_EVAL_LOC)),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let y1_plus_y3 := addmod(\\n                    mload(Y1_EVAL_LOC),\\n                    mload(Y3_EVAL_LOC),\\n                    p\\n                )\\n                let y_diff := addmod(mulmod(mload(Y2_EVAL_LOC), mload(QSIGN_LOC), p), sub(p, mload(Y1_EVAL_LOC)), p)\\n                let y_add_identity :=\\n                    addmod(\\n                        mulmod(y1_plus_y3, x_diff, p),\\n                        mulmod(addmod(mload(X3_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p), y_diff, p),\\n                        p\\n                    )\\n                y_add_identity :=\\n                    mulmod(\\n                        mulmod(y_add_identity, addmod(1, sub(p, mload(QM_EVAL_LOC)), p), p),\\n                        mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                        p\\n                    )\\n\\n                // ELLIPTIC_IDENTITY = (x_identity + y_identity) * Q_ELLIPTIC_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY, mulmod(addmod(x_add_identity, y_add_identity, p), mload(QELLIPTIC_EVAL_LOC), p)\\n                )\\n            }\\n            {\\n                /**\\n                 * x_pow_4 = (y_1_sqr - curve_b) * x_1;\\n                 * y_1_sqr_mul_4 = y_1_sqr + y_1_sqr;\\n                 * y_1_sqr_mul_4 += y_1_sqr_mul_4;\\n                 * x_1_pow_4_mul_9 = x_pow_4;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_pow_4;\\n                 * x_1_sqr_mul_3 = x_1_sqr + x_1_sqr + x_1_sqr;\\n                 * x_double_identity = (x_3 + x_1 + x_1) * y_1_sqr_mul_4 - x_1_pow_4_mul_9;\\n                 * y_double_identity = x_1_sqr_mul_3 * (x_1 - x_3) - (y_1 + y_1) * (y_1 + y_3);\\n                 */\\n                // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n                let x1_sqr := mulmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let x_pow_4 := mulmod(addmod(y1_sqr, GRUMPKIN_CURVE_B_PARAMETER_NEGATED, p), mload(X1_EVAL_LOC), p)\\n                let y1_sqr_mul_4 := mulmod(y1_sqr, 4, p)\\n                let x1_pow_4_mul_9 := mulmod(x_pow_4, 9, p)\\n                let x1_sqr_mul_3 := mulmod(x1_sqr, 3, p)\\n                let x_double_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            y1_sqr_mul_4,\\n                            p\\n                        ),\\n                        sub(p, x1_pow_4_mul_9),\\n                        p\\n                    )\\n                // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n                let y_double_identity :=\\n                    addmod(\\n                        mulmod(x1_sqr_mul_3, addmod(mload(X1_EVAL_LOC), sub(p, mload(X3_EVAL_LOC)), p), p),\\n                        sub(\\n                            p,\\n                            mulmod(\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p),\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y3_EVAL_LOC), p),\\n                                p\\n                            )\\n                        ),\\n                        p\\n                    )\\n                x_double_identity := mulmod(x_double_identity, mload(C_ALPHA_BASE_LOC), p)\\n                y_double_identity :=\\n                    mulmod(y_double_identity, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p), p)\\n                x_double_identity := mulmod(x_double_identity, mload(QM_EVAL_LOC), p)\\n                y_double_identity := mulmod(y_double_identity, mload(QM_EVAL_LOC), p)\\n                // ELLIPTIC_IDENTITY += (x_double_identity + y_double_identity) * Q_DOUBLE_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY,\\n                    addmod(\\n                        mload(ELLIPTIC_IDENTITY),\\n                        mulmod(addmod(x_double_identity, y_double_identity, p), mload(QELLIPTIC_EVAL_LOC), p),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE AUXILIARY WIDGET EVALUATION\\n             */\\n            {\\n                {\\n                    /**\\n                     * Non native field arithmetic gate 2\\n                     *             _                                                                               _\\n                     *            /   _                   _                               _       14                \\\\\\n                     * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n                     *            \\\\_                                                                               _/\\n                     *\\n                     * limb_subproduct = w_1 . w_2_omega + w_1_omega . w_2\\n                     * non_native_field_gate_2 = w_1 * w_4 + w_4 * w_3 - w_3_omega\\n                     * non_native_field_gate_2 = non_native_field_gate_2 * limb_size\\n                     * non_native_field_gate_2 -= w_4_omega\\n                     * non_native_field_gate_2 += limb_subproduct\\n                     * non_native_field_gate_2 *= q_4\\n                     * limb_subproduct *= limb_size\\n                     * limb_subproduct += w_1_omega * w_2_omega\\n                     * non_native_field_gate_1 = (limb_subproduct + w_3 + w_4) * q_3\\n                     * non_native_field_gate_3 = (limb_subproduct + w_4 - (w_3_omega + w_4_omega)) * q_m\\n                     * non_native_field_identity = (non_native_field_gate_1 + non_native_field_gate_2 + non_native_field_gate_3) * q_2\\n                     */\\n\\n                    let limb_subproduct :=\\n                        addmod(\\n                            mulmod(mload(W1_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p),\\n                            mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_EVAL_LOC), p),\\n                            p\\n                        )\\n\\n                    let non_native_field_gate_2 :=\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p),\\n                                mulmod(mload(W2_EVAL_LOC), mload(W3_EVAL_LOC), p),\\n                                p\\n                            ),\\n                            sub(p, mload(W3_OMEGA_EVAL_LOC)),\\n                            p\\n                        )\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, LIMB_SIZE, p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, limb_subproduct, p)\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, mload(Q4_EVAL_LOC), p)\\n                    limb_subproduct := mulmod(limb_subproduct, LIMB_SIZE, p)\\n                    limb_subproduct :=\\n                        addmod(limb_subproduct, mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p)\\n                    let non_native_field_gate_1 :=\\n                        mulmod(\\n                            addmod(limb_subproduct, sub(p, addmod(mload(W3_EVAL_LOC), mload(W4_EVAL_LOC), p)), p),\\n                            mload(Q3_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_gate_3 :=\\n                        mulmod(\\n                            addmod(\\n                                addmod(limb_subproduct, mload(W4_EVAL_LOC), p),\\n                                sub(p, addmod(mload(W3_OMEGA_EVAL_LOC), mload(W4_OMEGA_EVAL_LOC), p)),\\n                                p\\n                            ),\\n                            mload(QM_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_identity :=\\n                        mulmod(\\n                            addmod(addmod(non_native_field_gate_1, non_native_field_gate_2, p), non_native_field_gate_3, p),\\n                            mload(Q2_EVAL_LOC),\\n                            p\\n                        )\\n\\n                    mstore(AUX_NON_NATIVE_FIELD_EVALUATION, non_native_field_identity)\\n                }\\n\\n                {\\n                    /**\\n                     * limb_accumulator_1 = w_2_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_3;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_2;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1;\\n                     * limb_accumulator_1 -= w_4;\\n                     * limb_accumulator_1 *= q_4;\\n                     */\\n                    let limb_accumulator_1 := mulmod(mload(W2_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W2_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_EVAL_LOC), p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, sub(p, mload(W4_EVAL_LOC)), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, mload(Q4_EVAL_LOC), p)\\n\\n                    /**\\n                     * limb_accumulator_2 = w_3_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_2_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_1_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_4;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_3;\\n                     * limb_accumulator_2 -= w_4_omega;\\n                     * limb_accumulator_2 *= q_m;\\n                     */\\n                    let limb_accumulator_2 := mulmod(mload(W3_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W2_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W4_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, mload(QM_EVAL_LOC), p)\\n\\n                    mstore(\\n                        AUX_LIMB_ACCUMULATOR_EVALUATION,\\n                        mulmod(addmod(limb_accumulator_1, limb_accumulator_2, p), mload(Q3_EVAL_LOC), p)\\n                    )\\n                }\\n\\n                {\\n                    /**\\n                     * memory_record_check = w_3;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_2;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_1;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += q_c;\\n                     *\\n                     * partial_record_check = memory_record_check;\\n                     *\\n                     * memory_record_check -= w_4;\\n                     */\\n\\n                    let memory_record_check := mulmod(mload(W3_EVAL_LOC), mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W2_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W1_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(QC_EVAL_LOC), p)\\n\\n                    let partial_record_check := memory_record_check\\n                    memory_record_check := addmod(memory_record_check, sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                    mstore(AUX_MEMORY_EVALUATION, memory_record_check)\\n\\n                    // index_delta = w_1_omega - w_1\\n                    let index_delta := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                    // record_delta = w_4_omega - w_4\\n                    let record_delta := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n                    // index_is_monotonically_increasing = index_delta * (index_delta - 1)\\n                    let index_is_monotonically_increasing := mulmod(index_delta, addmod(index_delta, sub(p, 1), p), p)\\n\\n                    // adjacent_values_match_if_adjacent_indices_match = record_delta * (1 - index_delta)\\n                    let adjacent_values_match_if_adjacent_indices_match :=\\n                        mulmod(record_delta, addmod(1, sub(p, index_delta), p), p)\\n\\n                    // AUX_ROM_CONSISTENCY_EVALUATION = ((adjacent_values_match_if_adjacent_indices_match * alpha) + index_is_monotonically_increasing) * alpha + partial_record_check\\n                    mstore(\\n                        AUX_ROM_CONSISTENCY_EVALUATION,\\n                        addmod(\\n                            mulmod(\\n                                addmod(\\n                                    mulmod(adjacent_values_match_if_adjacent_indices_match, mload(C_ALPHA_LOC), p),\\n                                    index_is_monotonically_increasing,\\n                                    p\\n                                ),\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            ),\\n                            memory_record_check,\\n                            p\\n                        )\\n                    )\\n\\n                    {\\n                        /**\\n                         * next_gate_access_type = w_3_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_2_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_1_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type = w_4_omega - next_gate_access_type;\\n                         */\\n                        let next_gate_access_type := mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W2_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W1_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, next_gate_access_type), p)\\n\\n                        // value_delta = w_3_omega - w_3\\n                        let value_delta := addmod(mload(W3_OMEGA_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                        //  adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (1 - index_delta) * value_delta * (1 - next_gate_access_type);\\n\\n                        let adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation :=\\n                            mulmod(\\n                                addmod(1, sub(p, index_delta), p),\\n                                mulmod(value_delta, addmod(1, sub(p, next_gate_access_type), p), p),\\n                                p\\n                            )\\n\\n                        // AUX_RAM_CONSISTENCY_EVALUATION\\n\\n                        /**\\n                         * access_type = w_4 - partial_record_check\\n                         * access_check = access_type^2 - access_type\\n                         * next_gate_access_type_is_boolean = next_gate_access_type^2 - next_gate_access_type\\n                         * RAM_consistency_check_identity = adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += index_is_monotonically_increasing;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += next_gate_access_type_is_boolean;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += access_check;\\n                         */\\n\\n                        let access_type := addmod(mload(W4_EVAL_LOC), sub(p, partial_record_check), p)\\n                        let access_check := mulmod(access_type, addmod(access_type, sub(p, 1), p), p)\\n                        let next_gate_access_type_is_boolean :=\\n                            mulmod(next_gate_access_type, addmod(next_gate_access_type, sub(p, 1), p), p)\\n                        let RAM_cci :=\\n                            mulmod(\\n                                adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation,\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            )\\n                        RAM_cci := addmod(RAM_cci, index_is_monotonically_increasing, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, next_gate_access_type_is_boolean, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, access_check, p)\\n\\n                        mstore(AUX_RAM_CONSISTENCY_EVALUATION, RAM_cci)\\n                    }\\n\\n                    {\\n                        // timestamp_delta = w_2_omega - w_2\\n                        let timestamp_delta := addmod(mload(W2_OMEGA_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n\\n                        // RAM_timestamp_check_identity = (1 - index_delta) * timestamp_delta - w_3\\n                        let RAM_timestamp_check_identity :=\\n                            addmod(\\n                                mulmod(timestamp_delta, addmod(1, sub(p, index_delta), p), p), sub(p, mload(W3_EVAL_LOC)), p\\n                            )\\n\\n                        /**\\n                         * memory_identity = ROM_consistency_check_identity * q_2;\\n                         * memory_identity += RAM_timestamp_check_identity * q_4;\\n                         * memory_identity += memory_record_check * q_m;\\n                         * memory_identity *= q_1;\\n                         * memory_identity += (RAM_consistency_check_identity * q_arith);\\n                         *\\n                         * auxiliary_identity = memory_identity + non_native_field_identity + limb_accumulator_identity;\\n                         * auxiliary_identity *= q_aux;\\n                         * auxiliary_identity *= alpha_base;\\n                         */\\n                        let memory_identity := mulmod(mload(AUX_ROM_CONSISTENCY_EVALUATION), mload(Q2_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(RAM_timestamp_check_identity, mload(Q4_EVAL_LOC), p), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(mload(AUX_MEMORY_EVALUATION), mload(QM_EVAL_LOC), p), p)\\n                        memory_identity := mulmod(memory_identity, mload(Q1_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(\\n                                memory_identity, mulmod(mload(AUX_RAM_CONSISTENCY_EVALUATION), mload(QARITH_EVAL_LOC), p), p\\n                            )\\n\\n                        let auxiliary_identity := addmod(memory_identity, mload(AUX_NON_NATIVE_FIELD_EVALUATION), p)\\n                        auxiliary_identity := addmod(auxiliary_identity, mload(AUX_LIMB_ACCUMULATOR_EVALUATION), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(QAUX_EVAL_LOC), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(C_ALPHA_BASE_LOC), p)\\n\\n                        mstore(AUX_IDENTITY, auxiliary_identity)\\n\\n                        // update alpha\\n                        mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * quotient = ARITHMETIC_IDENTITY\\n                 * quotient += PERMUTATION_IDENTITY\\n                 * quotient += PLOOKUP_IDENTITY\\n                 * quotient += SORT_IDENTITY\\n                 * quotient += ELLIPTIC_IDENTITY\\n                 * quotient += AUX_IDENTITY\\n                 * quotient *= ZERO_POLY_INVERSE\\n                 */\\n                mstore(\\n                    QUOTIENT_EVAL_LOC,\\n                    mulmod(\\n                        addmod(\\n                            addmod(\\n                                addmod(\\n                                    addmod(\\n                                        addmod(mload(PERMUTATION_IDENTITY), mload(PLOOKUP_IDENTITY), p),\\n                                        mload(ARITHMETIC_IDENTITY),\\n                                        p\\n                                    ),\\n                                    mload(SORT_IDENTITY),\\n                                    p\\n                                ),\\n                                mload(ELLIPTIC_IDENTITY),\\n                                p\\n                            ),\\n                            mload(AUX_IDENTITY),\\n                            p\\n                        ),\\n                        mload(ZERO_POLY_INVERSE_LOC),\\n                        p\\n                    )\\n                )\\n            }\\n\\n            /**\\n             * GENERATE NU AND SEPARATOR CHALLENGES\\n             */\\n            {\\n                let current_challenge := mload(C_CURRENT_LOC)\\n                // get a calldata pointer that points to the start of the data we want to copy\\n                let calldata_ptr := add(calldataload(0x04), 0x24)\\n\\n                calldata_ptr := add(calldata_ptr, NU_CALLDATA_SKIP_LENGTH)\\n\\n                mstore(NU_CHALLENGE_INPUT_LOC_A, current_challenge)\\n                mstore(NU_CHALLENGE_INPUT_LOC_B, mload(QUOTIENT_EVAL_LOC))\\n                calldatacopy(NU_CHALLENGE_INPUT_LOC_C, calldata_ptr, NU_INPUT_LENGTH)\\n\\n                // hash length = (0x20 + num field elements), we include the previous challenge in the hash\\n                let challenge := keccak256(NU_CHALLENGE_INPUT_LOC_A, add(NU_INPUT_LENGTH, 0x40))\\n\\n                mstore(C_V0_LOC, mod(challenge, p))\\n                // We need THIRTY-ONE independent nu challenges!\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x02)\\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x03)\\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x04)\\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x05)\\n                mstore(C_V5_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x06)\\n                mstore(C_V6_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x07)\\n                mstore(C_V7_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x08)\\n                mstore(C_V8_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x09)\\n                mstore(C_V9_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0a)\\n                mstore(C_V10_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0b)\\n                mstore(C_V11_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0c)\\n                mstore(C_V12_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0d)\\n                mstore(C_V13_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0e)\\n                mstore(C_V14_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0f)\\n                mstore(C_V15_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x10)\\n                mstore(C_V16_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x11)\\n                mstore(C_V17_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x12)\\n                mstore(C_V18_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x13)\\n                mstore(C_V19_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x14)\\n                mstore(C_V20_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x15)\\n                mstore(C_V21_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x16)\\n                mstore(C_V22_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x17)\\n                mstore(C_V23_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x18)\\n                mstore(C_V24_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x19)\\n                mstore(C_V25_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1a)\\n                mstore(C_V26_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1b)\\n                mstore(C_V27_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1c)\\n                mstore(C_V28_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1d)\\n                mstore(C_V29_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                // @follow-up - Why are both v29 and v30 using appending 0x1d to the prior challenge and hashing, should it not change?\\n                mstore8(0x20, 0x1d)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_V30_LOC, mod(challenge, p))\\n\\n                // separator\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\\n\\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\\n            }\\n\\n            let success := 0\\n            // VALIDATE T1\\n            {\\n                let x := mload(T1_X_LOC)\\n                let y := mload(T1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                mstore(ACCUMULATOR_X_LOC, x)\\n                mstore(add(ACCUMULATOR_X_LOC, 0x20), y)\\n            }\\n            // VALIDATE T2\\n            {\\n                let x := mload(T2_X_LOC) // 0x1400\\n                let y := mload(T2_Y_LOC) // 0x1420\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(ZETA_POW_N_LOC))\\n            // accumulator_2 = [T2].zeta^n\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = [T1] + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T3\\n            {\\n                let x := mload(T3_X_LOC)\\n                let y := mload(T3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T3].zeta^{2n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T4\\n            {\\n                let x := mload(T4_X_LOC)\\n                let y := mload(T4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T4].zeta^{3n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W1\\n            {\\n                let x := mload(W1_X_LOC)\\n                let y := mload(W1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V0_LOC), p))\\n            // accumulator_2 = v0.(u + 1).[W1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W2\\n            {\\n                let x := mload(W2_X_LOC)\\n                let y := mload(W2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V1_LOC), p))\\n            // accumulator_2 = v1.(u + 1).[W2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W3\\n            {\\n                let x := mload(W3_X_LOC)\\n                let y := mload(W3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V2_LOC), p))\\n            // accumulator_2 = v2.(u + 1).[W3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W4\\n            {\\n                let x := mload(W4_X_LOC)\\n                let y := mload(W4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V3_LOC), p))\\n            // accumulator_2 = v3.(u + 1).[W4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE S\\n            {\\n                let x := mload(S_X_LOC)\\n                let y := mload(S_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V4_LOC), p))\\n            // accumulator_2 = v4.(u + 1).[S]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z\\n            {\\n                let x := mload(Z_X_LOC)\\n                let y := mload(Z_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V5_LOC), p))\\n            // accumulator_2 = v5.(u + 1).[Z]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z_LOOKUP\\n            {\\n                let x := mload(Z_LOOKUP_X_LOC)\\n                let y := mload(Z_LOOKUP_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V6_LOC), p))\\n            // accumulator_2 = v6.(u + 1).[Z_LOOKUP]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q1\\n            {\\n                let x := mload(Q1_X_LOC)\\n                let y := mload(Q1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V7_LOC))\\n            // accumulator_2 = v7.[Q1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q2\\n            {\\n                let x := mload(Q2_X_LOC)\\n                let y := mload(Q2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V8_LOC))\\n            // accumulator_2 = v8.[Q2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q3\\n            {\\n                let x := mload(Q3_X_LOC)\\n                let y := mload(Q3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V9_LOC))\\n            // accumulator_2 = v9.[Q3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q4\\n            {\\n                let x := mload(Q4_X_LOC)\\n                let y := mload(Q4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V10_LOC))\\n            // accumulator_2 = v10.[Q4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QM\\n            {\\n                let x := mload(QM_X_LOC)\\n                let y := mload(QM_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V11_LOC))\\n            // accumulator_2 = v11.[Q;]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QC\\n            {\\n                let x := mload(QC_X_LOC)\\n                let y := mload(QC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V12_LOC))\\n            // accumulator_2 = v12.[QC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QARITH\\n            {\\n                let x := mload(QARITH_X_LOC)\\n                let y := mload(QARITH_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V13_LOC))\\n            // accumulator_2 = v13.[QARITH]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QSORT\\n            {\\n                let x := mload(QSORT_X_LOC)\\n                let y := mload(QSORT_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V14_LOC))\\n            // accumulator_2 = v14.[QSORT]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QELLIPTIC\\n            {\\n                let x := mload(QELLIPTIC_X_LOC)\\n                let y := mload(QELLIPTIC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V15_LOC))\\n            // accumulator_2 = v15.[QELLIPTIC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QAUX\\n            {\\n                let x := mload(QAUX_X_LOC)\\n                let y := mload(QAUX_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V16_LOC))\\n            // accumulator_2 = v15.[Q_AUX]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA1\\n            {\\n                let x := mload(SIGMA1_X_LOC)\\n                let y := mload(SIGMA1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V17_LOC))\\n            // accumulator_2 = v17.[sigma1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA2\\n            {\\n                let x := mload(SIGMA2_X_LOC)\\n                let y := mload(SIGMA2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V18_LOC))\\n            // accumulator_2 = v18.[sigma2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA3\\n            {\\n                let x := mload(SIGMA3_X_LOC)\\n                let y := mload(SIGMA3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V19_LOC))\\n            // accumulator_2 = v19.[sigma3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA4\\n            {\\n                let x := mload(SIGMA4_X_LOC)\\n                let y := mload(SIGMA4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V20_LOC))\\n            // accumulator_2 = v20.[sigma4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE1\\n            {\\n                let x := mload(TABLE1_X_LOC)\\n                let y := mload(TABLE1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V21_LOC), p))\\n            // accumulator_2 = u.[table1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE2\\n            {\\n                let x := mload(TABLE2_X_LOC)\\n                let y := mload(TABLE2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V22_LOC), p))\\n            // accumulator_2 = u.[table2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE3\\n            {\\n                let x := mload(TABLE3_X_LOC)\\n                let y := mload(TABLE3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V23_LOC), p))\\n            // accumulator_2 = u.[table3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE4\\n            {\\n                let x := mload(TABLE4_X_LOC)\\n                let y := mload(TABLE4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V24_LOC), p))\\n            // accumulator_2 = u.[table4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE_TYPE\\n            {\\n                let x := mload(TABLE_TYPE_X_LOC)\\n                let y := mload(TABLE_TYPE_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V25_LOC))\\n            // accumulator_2 = v25.[TableType]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID1\\n            {\\n                let x := mload(ID1_X_LOC)\\n                let y := mload(ID1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V26_LOC))\\n            // accumulator_2 = v26.[ID1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID2\\n            {\\n                let x := mload(ID2_X_LOC)\\n                let y := mload(ID2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V27_LOC))\\n            // accumulator_2 = v27.[ID2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID3\\n            {\\n                let x := mload(ID3_X_LOC)\\n                let y := mload(ID3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V28_LOC))\\n            // accumulator_2 = v28.[ID3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID4\\n            {\\n                let x := mload(ID4_X_LOC)\\n                let y := mload(ID4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V29_LOC))\\n            // accumulator_2 = v29.[ID4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            /**\\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\\n             */\\n            {\\n                /**\\n                 * batch_evaluation = v0 * (w_1_omega * u + w_1_eval)\\n                 * batch_evaluation += v1 * (w_2_omega * u + w_2_eval)\\n                 * batch_evaluation += v2 * (w_3_omega * u + w_3_eval)\\n                 * batch_evaluation += v3 * (w_4_omega * u + w_4_eval)\\n                 * batch_evaluation += v4 * (s_omega_eval * u + s_eval)\\n                 * batch_evaluation += v5 * (z_omega_eval * u + z_eval)\\n                 * batch_evaluation += v6 * (z_lookup_omega_eval * u + z_lookup_eval)\\n                 */\\n                let batch_evaluation :=\\n                    mulmod(\\n                        mload(C_V0_LOC),\\n                        addmod(mulmod(mload(W1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W1_EVAL_LOC), p),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V1_LOC),\\n                            addmod(mulmod(mload(W2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V2_LOC),\\n                            addmod(mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V3_LOC),\\n                            addmod(mulmod(mload(W4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V4_LOC),\\n                            addmod(mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(S_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V5_LOC),\\n                            addmod(mulmod(mload(Z_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V6_LOC),\\n                            addmod(mulmod(mload(Z_LOOKUP_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_LOOKUP_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                /**\\n                 * batch_evaluation += v7 * Q1_EVAL\\n                 * batch_evaluation += v8 * Q2_EVAL\\n                 * batch_evaluation += v9 * Q3_EVAL\\n                 * batch_evaluation += v10 * Q4_EVAL\\n                 * batch_evaluation += v11 * QM_EVAL\\n                 * batch_evaluation += v12 * QC_EVAL\\n                 * batch_evaluation += v13 * QARITH_EVAL\\n                 * batch_evaluation += v14 * QSORT_EVAL_LOC\\n                 * batch_evaluation += v15 * QELLIPTIC_EVAL_LOC\\n                 * batch_evaluation += v16 * QAUX_EVAL_LOC\\n                 * batch_evaluation += v17 * SIGMA1_EVAL_LOC\\n                 * batch_evaluation += v18 * SIGMA2_EVAL_LOC\\n                 * batch_evaluation += v19 * SIGMA3_EVAL_LOC\\n                 * batch_evaluation += v20 * SIGMA4_EVAL_LOC\\n                 */\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V7_LOC), mload(Q1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V8_LOC), mload(Q2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V9_LOC), mload(Q3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V10_LOC), mload(Q4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V11_LOC), mload(QM_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V12_LOC), mload(QC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V13_LOC), mload(QARITH_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V14_LOC), mload(QSORT_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V15_LOC), mload(QELLIPTIC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V16_LOC), mload(QAUX_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V17_LOC), mload(SIGMA1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V18_LOC), mload(SIGMA2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V19_LOC), mload(SIGMA3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V20_LOC), mload(SIGMA4_EVAL_LOC), p), p)\\n\\n                /**\\n                 * batch_evaluation += v21 * (table1(zw) * u + table1(z))\\n                 * batch_evaluation += v22 * (table2(zw) * u + table2(z))\\n                 * batch_evaluation += v23 * (table3(zw) * u + table3(z))\\n                 * batch_evaluation += v24 * (table4(zw) * u + table4(z))\\n                 * batch_evaluation += v25 * table_type_eval\\n                 * batch_evaluation += v26 * id1_eval\\n                 * batch_evaluation += v27 * id2_eval\\n                 * batch_evaluation += v28 * id3_eval\\n                 * batch_evaluation += v29 * id4_eval\\n                 * batch_evaluation += quotient_eval\\n                 */\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V21_LOC),\\n                            addmod(mulmod(mload(TABLE1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE1_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V22_LOC),\\n                            addmod(mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V23_LOC),\\n                            addmod(mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V24_LOC),\\n                            addmod(mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V25_LOC), mload(TABLE_TYPE_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V26_LOC), mload(ID1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V27_LOC), mload(ID2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V28_LOC), mload(ID3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V29_LOC), mload(ID4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mload(QUOTIENT_EVAL_LOC), p)\\n\\n                mstore(0x00, 0x01) // [1].x\\n                mstore(0x20, 0x02) // [1].y\\n                mstore(0x40, sub(p, batch_evaluation))\\n                // accumulator_2 = -[1].(batch_evaluation)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                mstore(OPENING_COMMITMENT_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING PREAMBLE\\n             */\\n            {\\n                let u := mload(C_U_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                // VALIDATE PI_Z\\n                {\\n                    let x := mload(PI_Z_X_LOC)\\n                    let y := mload(PI_Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(0x40, zeta)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                // VALIDATE PI_Z_OMEGA\\n                {\\n                    let x := mload(PI_Z_OMEGA_X_LOC)\\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\\n                // accumulator_2 = u.zeta.omega.[PI_Z_OMEGA]\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // PAIRING_RHS = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                mstore(0x00, mload(PI_Z_X_LOC))\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, u)\\n                success := and(success, staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40))\\n                // PAIRING_LHS = [PI_Z] + [PI_Z_OMEGA] * u\\n                success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                // negate lhs y-coordinate\\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\\n\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    // VALIDATE RECURSIVE P1\\n                    {\\n                        let x := mload(RECURSIVE_P1_X_LOC)\\n                        let y := mload(RECURSIVE_P1_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n\\n                    // compute u.u.[recursive_p1] and write into 0x60\\n                    mstore(0x40, mulmod(u, u, p))\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\\n                    // VALIDATE RECURSIVE P2\\n                    {\\n                        let x := mload(RECURSIVE_P2_X_LOC)\\n                        let y := mload(RECURSIVE_P2_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n                    // compute u.u.[recursive_p2] and write into 0x00\\n                    // 0x40 still contains u*u\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\\n\\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                }\\n\\n                if iszero(success) {\\n                    mstore(0x0, EC_SCALAR_MUL_FAILURE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(PAIRING_PREAMBLE_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING\\n             */\\n            {\\n                // rhs paired with [1]_2\\n                // lhs paired with [x]_2\\n\\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\\n\\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\\n                mstore(0x100, mload(G2X_X0_LOC))\\n                mstore(0x120, mload(G2X_X1_LOC))\\n                mstore(0x140, mload(G2X_Y0_LOC))\\n                mstore(0x160, mload(G2X_Y1_LOC))\\n\\n                success := staticcall(gas(), 8, 0x00, 0x180, 0x00, 0x20)\\n                mstore(PAIRING_SUCCESS_FLAG, success)\\n                mstore(RESULT_FLAG, mload(0x00))\\n            }\\n            if iszero(\\n                and(\\n                    and(and(mload(PAIRING_SUCCESS_FLAG), mload(RESULT_FLAG)), mload(PAIRING_PREAMBLE_SUCCESS_FLAG)),\\n                    mload(OPENING_COMMITMENT_SUCCESS_FLAG)\\n                )\\n            ) {\\n                mstore(0x0, PROOF_FAILURE_SELECTOR)\\n                revert(0x00, 0x04)\\n            }\\n            {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20) // Proof succeeded!\\n            }\\n        }\\n    }\\n}\\n\\ncontract PasskeyUltraVerifier is PasskeyBaseUltraVerifier {\\n    function getVerificationKeyHash() public pure override(PasskeyBaseUltraVerifier) returns (bytes32) {\\n        return PasskeyUltraVerificationKey.verificationKeyHash();\\n    }\\n\\n    function loadVerificationKey(uint256 vk, uint256 _omegaInverseLoc) internal pure virtual override(PasskeyBaseUltraVerifier) {\\n        PasskeyUltraVerificationKey.loadVerificationKey(vk, _omegaInverseLoc);\\n    }\\n}\\n\",\"keccak256\":\"0x2eecf173718c7ad908bacc05dfa38a463babb34192281f29ca4ce34b1fa62c51\",\"license\":\"Apache-2.0\"},\"contracts/verifier/RecoveryVerifier.sol\":{\"content\":\"// Verification Key Hash: 9b374aa32d4e3875ad4522edd0900eb7a75bc93ec40ac7a89128fc56ccaaea3d\\n// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary RecoveryUltraVerificationKey {\\n    function verificationKeyHash() internal pure returns(bytes32) {\\n        return 0x9b374aa32d4e3875ad4522edd0900eb7a75bc93ec40ac7a89128fc56ccaaea3d;\\n    }\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure {\\n        assembly {\\n            mstore(add(_vk, 0x00), 0x0000000000000000000000000000000000000000000000000000000000010000) // vk.circuit_size\\n            mstore(add(_vk, 0x20), 0x0000000000000000000000000000000000000000000000000000000000000021) // vk.num_inputs\\n            mstore(add(_vk, 0x40), 0x00eeb2cb5981ed45649abebde081dcff16c8601de4347e7dd1628ba2daac43b7) // vk.work_root\\n            mstore(add(_vk, 0x60), 0x30641e0e92bebef818268d663bcad6dbcfd6c0149170f6d7d350b1b1fa6c1001) // vk.domain_inverse\\n            mstore(add(_vk, 0x80), 0x0eb95f248d9300d03f8196c212fd7f9b38d1145eec9a5758c72aff9cbfab8620) // vk.Q1.x\\n            mstore(add(_vk, 0xa0), 0x15aa16517b667ff19116e19781d86215e8b6b2bb1c9fd56ecbd4678f617fec75) // vk.Q1.y\\n            mstore(add(_vk, 0xc0), 0x162f8aaeb8bb9219589cda5906c2f1283f5ad5dd6393a557323584dd1e29607f) // vk.Q2.x\\n            mstore(add(_vk, 0xe0), 0x29dff15e7566ff188bb45cc619842f3eca0736e014878a1c8e49a1b672643012) // vk.Q2.y\\n            mstore(add(_vk, 0x100), 0x29e2c511df8798eca9dea94063bbe91c33ee2d5144eade9b88026fa502f9bda0) // vk.Q3.x\\n            mstore(add(_vk, 0x120), 0x22d3d23dd71b003f433b27028754dca9ee05159ccb5bf15d033249fdbdfce544) // vk.Q3.y\\n            mstore(add(_vk, 0x140), 0x11e5b3828f82fe62de6cc9041ba8f346522d0246643041c8ea073757718e426f) // vk.Q4.x\\n            mstore(add(_vk, 0x160), 0x252d20f47d24f3ff030ac83a62600c3e7cec08cd848fd145c3a7e5b8800e9b71) // vk.Q4.y\\n            mstore(add(_vk, 0x180), 0x105b5509ce8aa249f12445b18d1755633e3916dacfe05eaadeaa87de4c6eb9b5) // vk.Q_M.x\\n            mstore(add(_vk, 0x1a0), 0x1b79cabc2d8824ab871a758fa70e25f54e4f8f25e16f1f59ed8a6d26d2e8b367) // vk.Q_M.y\\n            mstore(add(_vk, 0x1c0), 0x267e3bdb5f51ba31dc3c1e6c64a31716bdfa97d74fbbbdd79a04b12190676f34) // vk.Q_C.x\\n            mstore(add(_vk, 0x1e0), 0x0805c01f4a5afd6939ef35dd0a1f1e3e99fb2ef6678eac934b9b83d30bb46e4e) // vk.Q_C.y\\n            mstore(add(_vk, 0x200), 0x042553e8b782c3afb0a33cb847dd6915c094472627e4ef1a164b050272512e8c) // vk.Q_ARITHMETIC.x\\n            mstore(add(_vk, 0x220), 0x20590c1606831f64198b9e48466417a2a79d1b7223ed6f9bc92cd08b00bda546) // vk.Q_ARITHMETIC.y\\n            mstore(add(_vk, 0x240), 0x03aebe5481267568fd9a2327c6b2c48cfb9bf101f787438abee1d8f7353b120a) // vk.QSORT.x\\n            mstore(add(_vk, 0x260), 0x162d38ecc28c26bf1774e048e75a0de1b8cfb63b8d2ba8fa45f9e95a9eca35f6) // vk.QSORT.y\\n            mstore(add(_vk, 0x280), 0x21245d6c0a4d2ff12b21a825f39f30e8f8cf9b259448d111183e975828539576) // vk.Q_ELLIPTIC.x\\n            mstore(add(_vk, 0x2a0), 0x16a409532c8a1693536e93b6ce9920bfc2e6796e8dfe404675a0cdf6ee77ee7a) // vk.Q_ELLIPTIC.y\\n            mstore(add(_vk, 0x2c0), 0x0e62f87f6f17c74bc63f8480bc5eae0828985cc84ced5b74a386fd932b426810) // vk.Q_AUX.x\\n            mstore(add(_vk, 0x2e0), 0x1ce43c4c9097bf6f752629c56d5d1f491c20a8fb42bb490f1937690d4b240ce8) // vk.Q_AUX.y\\n            mstore(add(_vk, 0x300), 0x1d8781fd240a7ce36cb659e00af11c9f77836ba0e78d97a0866d310c07fe8b23) // vk.SIGMA1.x\\n            mstore(add(_vk, 0x320), 0x228fd1fd70131f7f7fbed3cc00f190b18665d33d9ed55a583ae2871c7b75798e) // vk.SIGMA1.y\\n            mstore(add(_vk, 0x340), 0x20aebdab132f247f3670d72655741cc1a85ed19402e01a2b38368512096600c0) // vk.SIGMA2.x\\n            mstore(add(_vk, 0x360), 0x1ef659e0c61d54d25fa031b8f18a65938daf77f68f093566f0747500e54e20bd) // vk.SIGMA2.y\\n            mstore(add(_vk, 0x380), 0x10a52caf24669d15874bcc4f2041d92b1c62ac3c34fa07927f831f0bdaa6a8ea) // vk.SIGMA3.x\\n            mstore(add(_vk, 0x3a0), 0x03ebcdf4a52620cf57775f0f9affec31db308e980c561124edf70e3234144311) // vk.SIGMA3.y\\n            mstore(add(_vk, 0x3c0), 0x091a2b62a124cafd64e33109c88f275fd214c6848ff9aa94cbf6f0131bd85955) // vk.SIGMA4.x\\n            mstore(add(_vk, 0x3e0), 0x1da11c9488eee0a60af0be694c081a9573be9627bacf3844ef1ab1720c1956bf) // vk.SIGMA4.y\\n            mstore(add(_vk, 0x400), 0x06e6d1480535f6e29a6713cd5c4e668464cbdac425322b2d3b98a34e8834c14f) // vk.TABLE1.x\\n            mstore(add(_vk, 0x420), 0x15c1b7ea4800a867676fc4c79695b5b27b0e702d7d6188d0ad0259936cb3e55f) // vk.TABLE1.y\\n            mstore(add(_vk, 0x440), 0x030b16cd4d48e7b40d2ac90b515369aabc0c273bd7c77f122e9993c2251f7f4a) // vk.TABLE2.x\\n            mstore(add(_vk, 0x460), 0x07578950db871ef62bab02e94473298e53701113cc0c09573d1ccdbb99ab49b7) // vk.TABLE2.y\\n            mstore(add(_vk, 0x480), 0x1bbfe736b28dc8ede22ad6ba3ecec3607de18a29cee6828a7303d33ceb1e2ef0) // vk.TABLE3.x\\n            mstore(add(_vk, 0x4a0), 0x2e0a348344704012f149db2aed39ea37d1fe96d4d91f803026f17ed9a0449907) // vk.TABLE3.y\\n            mstore(add(_vk, 0x4c0), 0x273714e498d7ee7471cf8859c5db4113e86f6acee195b29fd0e5953728135962) // vk.TABLE4.x\\n            mstore(add(_vk, 0x4e0), 0x2997e7f0a5012a52da8388d912ce58fffbab8f6b5d56b6c289ab367fd72f242a) // vk.TABLE4.y\\n            mstore(add(_vk, 0x500), 0x27c47a96996a3a7d9ffac555d4a7650ef05f49324b63c57137f413a33de1ec8e) // vk.TABLE_TYPE.x\\n            mstore(add(_vk, 0x520), 0x2a16ffd7bd4f4a524b6185e4089f15a61b6c2195aaf54b156b54cd6c3a15f51b) // vk.TABLE_TYPE.y\\n            mstore(add(_vk, 0x540), 0x172dedb8cad9ff8d2bee0265451ec9fda8d406d52adc2ad564d9e858d84433f0) // vk.ID1.x\\n            mstore(add(_vk, 0x560), 0x0c94d35ed9bb8eee5505028d4293ddd501a36f9549a1f9607215aae5926f2e44) // vk.ID1.y\\n            mstore(add(_vk, 0x580), 0x2c5e65d1f63c6b6beeca6a66ebb34a327ac69983f783123699f0089e944234ed) // vk.ID2.x\\n            mstore(add(_vk, 0x5a0), 0x28eaab3fdc69c35d079778a5b02d088cd7ebf38d60511a79ce847baae97176eb) // vk.ID2.y\\n            mstore(add(_vk, 0x5c0), 0x25588bd115d4b99f51d0205fc3c856804d6cc827c4e6b3fe2a37f22021bdfdd8) // vk.ID3.x\\n            mstore(add(_vk, 0x5e0), 0x0b4cc68e330d4e9b99d629829adf4bac278457b8a8c44cf458d8047c46cc0533) // vk.ID3.y\\n            mstore(add(_vk, 0x600), 0x2aee25fcb803dabf17d40dce2f7cf592c55a27b20d5f8c6f337452b0e694b685) // vk.ID4.x\\n            mstore(add(_vk, 0x620), 0x12e71a9fa4bf6c014056967fe1176076d1a481529a8460f7ee68a6397adccb7e) // vk.ID4.y\\n            mstore(add(_vk, 0x640), 0x00) // vk.contains_recursive_proof\\n            mstore(add(_vk, 0x660), 0) // vk.recursive_proof_public_input_indices\\n            mstore(add(_vk, 0x680), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1 \\n            mstore(add(_vk, 0x6a0), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0 \\n            mstore(add(_vk, 0x6c0), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1 \\n            mstore(add(_vk, 0x6e0), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0 \\n            mstore(_omegaInverseLoc, 0x0b5d56b77fe704e8e92338c0082f37e091126414c830e4c6922d5ac802d842d4) // vk.work_root_inverse\\n        }\\n    }\\n}\\n/**\\n * @title Ultra Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n */\\nabstract contract RecoveryBaseUltraVerifier {\\n    // VERIFICATION KEY MEMORY LOCATIONS\\n    uint256 internal constant N_LOC = 0x380;\\n    uint256 internal constant NUM_INPUTS_LOC = 0x3a0;\\n    uint256 internal constant OMEGA_LOC = 0x3c0;\\n    uint256 internal constant DOMAIN_INVERSE_LOC = 0x3e0;\\n    uint256 internal constant Q1_X_LOC = 0x400;\\n    uint256 internal constant Q1_Y_LOC = 0x420;\\n    uint256 internal constant Q2_X_LOC = 0x440;\\n    uint256 internal constant Q2_Y_LOC = 0x460;\\n    uint256 internal constant Q3_X_LOC = 0x480;\\n    uint256 internal constant Q3_Y_LOC = 0x4a0;\\n    uint256 internal constant Q4_X_LOC = 0x4c0;\\n    uint256 internal constant Q4_Y_LOC = 0x4e0;\\n    uint256 internal constant QM_X_LOC = 0x500;\\n    uint256 internal constant QM_Y_LOC = 0x520;\\n    uint256 internal constant QC_X_LOC = 0x540;\\n    uint256 internal constant QC_Y_LOC = 0x560;\\n    uint256 internal constant QARITH_X_LOC = 0x580;\\n    uint256 internal constant QARITH_Y_LOC = 0x5a0;\\n    uint256 internal constant QSORT_X_LOC = 0x5c0;\\n    uint256 internal constant QSORT_Y_LOC = 0x5e0;\\n    uint256 internal constant QELLIPTIC_X_LOC = 0x600;\\n    uint256 internal constant QELLIPTIC_Y_LOC = 0x620;\\n    uint256 internal constant QAUX_X_LOC = 0x640;\\n    uint256 internal constant QAUX_Y_LOC = 0x660;\\n    uint256 internal constant SIGMA1_X_LOC = 0x680;\\n    uint256 internal constant SIGMA1_Y_LOC = 0x6a0;\\n    uint256 internal constant SIGMA2_X_LOC = 0x6c0;\\n    uint256 internal constant SIGMA2_Y_LOC = 0x6e0;\\n    uint256 internal constant SIGMA3_X_LOC = 0x700;\\n    uint256 internal constant SIGMA3_Y_LOC = 0x720;\\n    uint256 internal constant SIGMA4_X_LOC = 0x740;\\n    uint256 internal constant SIGMA4_Y_LOC = 0x760;\\n    uint256 internal constant TABLE1_X_LOC = 0x780;\\n    uint256 internal constant TABLE1_Y_LOC = 0x7a0;\\n    uint256 internal constant TABLE2_X_LOC = 0x7c0;\\n    uint256 internal constant TABLE2_Y_LOC = 0x7e0;\\n    uint256 internal constant TABLE3_X_LOC = 0x800;\\n    uint256 internal constant TABLE3_Y_LOC = 0x820;\\n    uint256 internal constant TABLE4_X_LOC = 0x840;\\n    uint256 internal constant TABLE4_Y_LOC = 0x860;\\n    uint256 internal constant TABLE_TYPE_X_LOC = 0x880;\\n    uint256 internal constant TABLE_TYPE_Y_LOC = 0x8a0;\\n    uint256 internal constant ID1_X_LOC = 0x8c0;\\n    uint256 internal constant ID1_Y_LOC = 0x8e0;\\n    uint256 internal constant ID2_X_LOC = 0x900;\\n    uint256 internal constant ID2_Y_LOC = 0x920;\\n    uint256 internal constant ID3_X_LOC = 0x940;\\n    uint256 internal constant ID3_Y_LOC = 0x960;\\n    uint256 internal constant ID4_X_LOC = 0x980;\\n    uint256 internal constant ID4_Y_LOC = 0x9a0;\\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC = 0x9c0;\\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x9e0;\\n    uint256 internal constant G2X_X0_LOC = 0xa00;\\n    uint256 internal constant G2X_X1_LOC = 0xa20;\\n    uint256 internal constant G2X_Y0_LOC = 0xa40;\\n    uint256 internal constant G2X_Y1_LOC = 0xa60;\\n\\n    // ### PROOF DATA MEMORY LOCATIONS\\n    uint256 internal constant W1_X_LOC = 0x1200;\\n    uint256 internal constant W1_Y_LOC = 0x1220;\\n    uint256 internal constant W2_X_LOC = 0x1240;\\n    uint256 internal constant W2_Y_LOC = 0x1260;\\n    uint256 internal constant W3_X_LOC = 0x1280;\\n    uint256 internal constant W3_Y_LOC = 0x12a0;\\n    uint256 internal constant W4_X_LOC = 0x12c0;\\n    uint256 internal constant W4_Y_LOC = 0x12e0;\\n    uint256 internal constant S_X_LOC = 0x1300;\\n    uint256 internal constant S_Y_LOC = 0x1320;\\n    uint256 internal constant Z_X_LOC = 0x1340;\\n    uint256 internal constant Z_Y_LOC = 0x1360;\\n    uint256 internal constant Z_LOOKUP_X_LOC = 0x1380;\\n    uint256 internal constant Z_LOOKUP_Y_LOC = 0x13a0;\\n    uint256 internal constant T1_X_LOC = 0x13c0;\\n    uint256 internal constant T1_Y_LOC = 0x13e0;\\n    uint256 internal constant T2_X_LOC = 0x1400;\\n    uint256 internal constant T2_Y_LOC = 0x1420;\\n    uint256 internal constant T3_X_LOC = 0x1440;\\n    uint256 internal constant T3_Y_LOC = 0x1460;\\n    uint256 internal constant T4_X_LOC = 0x1480;\\n    uint256 internal constant T4_Y_LOC = 0x14a0;\\n\\n    uint256 internal constant W1_EVAL_LOC = 0x1600;\\n    uint256 internal constant W2_EVAL_LOC = 0x1620;\\n    uint256 internal constant W3_EVAL_LOC = 0x1640;\\n    uint256 internal constant W4_EVAL_LOC = 0x1660;\\n    uint256 internal constant S_EVAL_LOC = 0x1680;\\n    uint256 internal constant Z_EVAL_LOC = 0x16a0;\\n    uint256 internal constant Z_LOOKUP_EVAL_LOC = 0x16c0;\\n    uint256 internal constant Q1_EVAL_LOC = 0x16e0;\\n    uint256 internal constant Q2_EVAL_LOC = 0x1700;\\n    uint256 internal constant Q3_EVAL_LOC = 0x1720;\\n    uint256 internal constant Q4_EVAL_LOC = 0x1740;\\n    uint256 internal constant QM_EVAL_LOC = 0x1760;\\n    uint256 internal constant QC_EVAL_LOC = 0x1780;\\n    uint256 internal constant QARITH_EVAL_LOC = 0x17a0;\\n    uint256 internal constant QSORT_EVAL_LOC = 0x17c0;\\n    uint256 internal constant QELLIPTIC_EVAL_LOC = 0x17e0;\\n    uint256 internal constant QAUX_EVAL_LOC = 0x1800;\\n    uint256 internal constant TABLE1_EVAL_LOC = 0x1840;\\n    uint256 internal constant TABLE2_EVAL_LOC = 0x1860;\\n    uint256 internal constant TABLE3_EVAL_LOC = 0x1880;\\n    uint256 internal constant TABLE4_EVAL_LOC = 0x18a0;\\n    uint256 internal constant TABLE_TYPE_EVAL_LOC = 0x18c0;\\n    uint256 internal constant ID1_EVAL_LOC = 0x18e0;\\n    uint256 internal constant ID2_EVAL_LOC = 0x1900;\\n    uint256 internal constant ID3_EVAL_LOC = 0x1920;\\n    uint256 internal constant ID4_EVAL_LOC = 0x1940;\\n    uint256 internal constant SIGMA1_EVAL_LOC = 0x1960;\\n    uint256 internal constant SIGMA2_EVAL_LOC = 0x1980;\\n    uint256 internal constant SIGMA3_EVAL_LOC = 0x19a0;\\n    uint256 internal constant SIGMA4_EVAL_LOC = 0x19c0;\\n    uint256 internal constant W1_OMEGA_EVAL_LOC = 0x19e0;\\n    uint256 internal constant W2_OMEGA_EVAL_LOC = 0x2000;\\n    uint256 internal constant W3_OMEGA_EVAL_LOC = 0x2020;\\n    uint256 internal constant W4_OMEGA_EVAL_LOC = 0x2040;\\n    uint256 internal constant S_OMEGA_EVAL_LOC = 0x2060;\\n    uint256 internal constant Z_OMEGA_EVAL_LOC = 0x2080;\\n    uint256 internal constant Z_LOOKUP_OMEGA_EVAL_LOC = 0x20a0;\\n    uint256 internal constant TABLE1_OMEGA_EVAL_LOC = 0x20c0;\\n    uint256 internal constant TABLE2_OMEGA_EVAL_LOC = 0x20e0;\\n    uint256 internal constant TABLE3_OMEGA_EVAL_LOC = 0x2100;\\n    uint256 internal constant TABLE4_OMEGA_EVAL_LOC = 0x2120;\\n\\n    uint256 internal constant PI_Z_X_LOC = 0x2300;\\n    uint256 internal constant PI_Z_Y_LOC = 0x2320;\\n    uint256 internal constant PI_Z_OMEGA_X_LOC = 0x2340;\\n    uint256 internal constant PI_Z_OMEGA_Y_LOC = 0x2360;\\n\\n    // Used for elliptic widget. These are alias names for wire + shifted wire evaluations\\n    uint256 internal constant X1_EVAL_LOC = W2_EVAL_LOC;\\n    uint256 internal constant X2_EVAL_LOC = W1_OMEGA_EVAL_LOC;\\n    uint256 internal constant X3_EVAL_LOC = W2_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y1_EVAL_LOC = W3_EVAL_LOC;\\n    uint256 internal constant Y2_EVAL_LOC = W4_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y3_EVAL_LOC = W3_OMEGA_EVAL_LOC;\\n    uint256 internal constant QBETA_LOC = Q3_EVAL_LOC;\\n    uint256 internal constant QBETA_SQR_LOC = Q4_EVAL_LOC;\\n    uint256 internal constant QSIGN_LOC = Q1_EVAL_LOC;\\n\\n    // ### CHALLENGES MEMORY OFFSETS\\n\\n    uint256 internal constant C_BETA_LOC = 0x2600;\\n    uint256 internal constant C_GAMMA_LOC = 0x2620;\\n    uint256 internal constant C_ALPHA_LOC = 0x2640;\\n    uint256 internal constant C_ETA_LOC = 0x2660;\\n    uint256 internal constant C_ETA_SQR_LOC = 0x2680;\\n    uint256 internal constant C_ETA_CUBE_LOC = 0x26a0;\\n\\n    uint256 internal constant C_ZETA_LOC = 0x26c0;\\n    uint256 internal constant C_CURRENT_LOC = 0x26e0;\\n    uint256 internal constant C_V0_LOC = 0x2700;\\n    uint256 internal constant C_V1_LOC = 0x2720;\\n    uint256 internal constant C_V2_LOC = 0x2740;\\n    uint256 internal constant C_V3_LOC = 0x2760;\\n    uint256 internal constant C_V4_LOC = 0x2780;\\n    uint256 internal constant C_V5_LOC = 0x27a0;\\n    uint256 internal constant C_V6_LOC = 0x27c0;\\n    uint256 internal constant C_V7_LOC = 0x27e0;\\n    uint256 internal constant C_V8_LOC = 0x2800;\\n    uint256 internal constant C_V9_LOC = 0x2820;\\n    uint256 internal constant C_V10_LOC = 0x2840;\\n    uint256 internal constant C_V11_LOC = 0x2860;\\n    uint256 internal constant C_V12_LOC = 0x2880;\\n    uint256 internal constant C_V13_LOC = 0x28a0;\\n    uint256 internal constant C_V14_LOC = 0x28c0;\\n    uint256 internal constant C_V15_LOC = 0x28e0;\\n    uint256 internal constant C_V16_LOC = 0x2900;\\n    uint256 internal constant C_V17_LOC = 0x2920;\\n    uint256 internal constant C_V18_LOC = 0x2940;\\n    uint256 internal constant C_V19_LOC = 0x2960;\\n    uint256 internal constant C_V20_LOC = 0x2980;\\n    uint256 internal constant C_V21_LOC = 0x29a0;\\n    uint256 internal constant C_V22_LOC = 0x29c0;\\n    uint256 internal constant C_V23_LOC = 0x29e0;\\n    uint256 internal constant C_V24_LOC = 0x2a00;\\n    uint256 internal constant C_V25_LOC = 0x2a20;\\n    uint256 internal constant C_V26_LOC = 0x2a40;\\n    uint256 internal constant C_V27_LOC = 0x2a60;\\n    uint256 internal constant C_V28_LOC = 0x2a80;\\n    uint256 internal constant C_V29_LOC = 0x2aa0;\\n    uint256 internal constant C_V30_LOC = 0x2ac0;\\n\\n    uint256 internal constant C_U_LOC = 0x2b00;\\n\\n    // ### LOCAL VARIABLES MEMORY OFFSETS\\n    uint256 internal constant DELTA_NUMERATOR_LOC = 0x3000;\\n    uint256 internal constant DELTA_DENOMINATOR_LOC = 0x3020;\\n    uint256 internal constant ZETA_POW_N_LOC = 0x3040;\\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC = 0x3060;\\n    uint256 internal constant ZERO_POLY_LOC = 0x3080;\\n    uint256 internal constant L_START_LOC = 0x30a0;\\n    uint256 internal constant L_END_LOC = 0x30c0;\\n    uint256 internal constant R_ZERO_EVAL_LOC = 0x30e0;\\n\\n    uint256 internal constant PLOOKUP_DELTA_NUMERATOR_LOC = 0x3100;\\n    uint256 internal constant PLOOKUP_DELTA_DENOMINATOR_LOC = 0x3120;\\n    uint256 internal constant PLOOKUP_DELTA_LOC = 0x3140;\\n\\n    uint256 internal constant ACCUMULATOR_X_LOC = 0x3160;\\n    uint256 internal constant ACCUMULATOR_Y_LOC = 0x3180;\\n    uint256 internal constant ACCUMULATOR2_X_LOC = 0x31a0;\\n    uint256 internal constant ACCUMULATOR2_Y_LOC = 0x31c0;\\n    uint256 internal constant PAIRING_LHS_X_LOC = 0x31e0;\\n    uint256 internal constant PAIRING_LHS_Y_LOC = 0x3200;\\n    uint256 internal constant PAIRING_RHS_X_LOC = 0x3220;\\n    uint256 internal constant PAIRING_RHS_Y_LOC = 0x3240;\\n\\n    // ### SUCCESS FLAG MEMORY LOCATIONS\\n    uint256 internal constant GRAND_PRODUCT_SUCCESS_FLAG = 0x3300;\\n    uint256 internal constant ARITHMETIC_TERM_SUCCESS_FLAG = 0x3020;\\n    uint256 internal constant BATCH_OPENING_SUCCESS_FLAG = 0x3340;\\n    uint256 internal constant OPENING_COMMITMENT_SUCCESS_FLAG = 0x3360;\\n    uint256 internal constant PAIRING_PREAMBLE_SUCCESS_FLAG = 0x3380;\\n    uint256 internal constant PAIRING_SUCCESS_FLAG = 0x33a0;\\n    uint256 internal constant RESULT_FLAG = 0x33c0;\\n\\n    // misc stuff\\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x3400;\\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x3420;\\n    uint256 internal constant C_ALPHA_CUBE_LOC = 0x3440;\\n    uint256 internal constant C_ALPHA_QUAD_LOC = 0x3460;\\n    uint256 internal constant C_ALPHA_BASE_LOC = 0x3480;\\n\\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x3500;\\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x3520;\\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x3540;\\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x3560;\\n\\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x3580;\\n\\n    // sub-identity storage\\n    uint256 internal constant PERMUTATION_IDENTITY = 0x3600;\\n    uint256 internal constant PLOOKUP_IDENTITY = 0x3620;\\n    uint256 internal constant ARITHMETIC_IDENTITY = 0x3640;\\n    uint256 internal constant SORT_IDENTITY = 0x3660;\\n    uint256 internal constant ELLIPTIC_IDENTITY = 0x3680;\\n    uint256 internal constant AUX_IDENTITY = 0x36a0;\\n    uint256 internal constant AUX_NON_NATIVE_FIELD_EVALUATION = 0x36c0;\\n    uint256 internal constant AUX_LIMB_ACCUMULATOR_EVALUATION = 0x36e0;\\n    uint256 internal constant AUX_RAM_CONSISTENCY_EVALUATION = 0x3700;\\n    uint256 internal constant AUX_ROM_CONSISTENCY_EVALUATION = 0x3720;\\n    uint256 internal constant AUX_MEMORY_EVALUATION = 0x3740;\\n\\n    uint256 internal constant QUOTIENT_EVAL_LOC = 0x3760;\\n    uint256 internal constant ZERO_POLY_INVERSE_LOC = 0x3780;\\n\\n    // when hashing public inputs we use memory at NU_CHALLENGE_INPUT_LOC_A, as the hash input size is unknown at compile time\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_A = 0x37a0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_B = 0x37c0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_C = 0x37e0;\\n\\n    bytes4 internal constant PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR = 0xeba9f4a6;\\n    bytes4 internal constant PUBLIC_INPUT_GE_P_SELECTOR = 0x374a972f;\\n    bytes4 internal constant MOD_EXP_FAILURE_SELECTOR = 0xf894a7bc;\\n    bytes4 internal constant EC_SCALAR_MUL_FAILURE_SELECTOR = 0xf755f369;\\n    bytes4 internal constant PROOF_FAILURE_SELECTOR = 0x0711fcec;\\n\\n    uint256 internal constant ETA_INPUT_LENGTH = 0xc0; // W1, W2, W3 = 6 * 0x20 bytes\\n\\n    // We need to hash 41 field elements when generating the NU challenge\\n    // w1, w2, w3, w4, s, z, z_lookup, q1, q2, q3, q4, qm, qc, qarith (14)\\n    // qsort, qelliptic, qaux, sigma1, sigma2, sigma, sigma4, (7)\\n    // table1, table2, table3, table4, tabletype, id1, id2, id3, id4, (9)\\n    // w1_omega, w2_omega, w3_omega, w4_omega, s_omega, z_omega, z_lookup_omega, (7)\\n    // table1_omega, table2_omega, table3_omega, table4_omega (4)\\n    uint256 internal constant NU_INPUT_LENGTH = 0x520; // 0x520 = 41 * 0x20\\n\\n    // There are ELEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n    // W1, W2, W3, W4, S, Z, Z_LOOKUP, T1, T2, T3, T4\\n    uint256 internal constant NU_CALLDATA_SKIP_LENGTH = 0x2c0; // 11 * 0x40 = 0x2c0\\n\\n    uint256 internal constant NEGATIVE_INVERSE_OF_2_MODULO_P =\\n        0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    uint256 internal constant LIMB_SIZE = 0x100000000000000000; // 2<<68\\n    uint256 internal constant SUBLIMB_SHIFT = 0x4000; // 2<<14\\n\\n    // y^2 = x^3 + ax + b\\n    // for Grumpkin, a = 0 and b = -17. We use b in a custom gate relation that evaluates elliptic curve arithmetic\\n    uint256 internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = 17;\\n    error PUBLIC_INPUT_COUNT_INVALID(uint256 expected, uint256 actual);\\n    error PUBLIC_INPUT_INVALID_BN128_G1_POINT();\\n    error PUBLIC_INPUT_GE_P();\\n    error MOD_EXP_FAILURE();\\n    error EC_SCALAR_MUL_FAILURE();\\n    error PROOF_FAILURE();\\n\\n    function getVerificationKeyHash() public pure virtual returns (bytes32);\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure virtual;\\n\\n    /**\\n     * @notice Verify a Ultra Plonk proof\\n     * @param _proof - The serialized proof\\n     * @param _publicInputs - An array of the public inputs\\n     * @return True if proof is valid, reverts otherwise\\n     */\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool) {\\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\\n\\n        uint256 requiredPublicInputCount;\\n        assembly {\\n            requiredPublicInputCount := mload(NUM_INPUTS_LOC)\\n        }\\n        if (requiredPublicInputCount != _publicInputs.length) {\\n            revert PUBLIC_INPUT_COUNT_INVALID(requiredPublicInputCount, _publicInputs.length);\\n        }\\n\\n        assembly {\\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\\n\\n            /**\\n             * LOAD PROOF FROM CALLDATA\\n             */\\n            {\\n                let data_ptr := add(calldataload(0x04), 0x24)\\n\\n                mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\\n                mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\\n\\n                mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\\n                mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\\n\\n                mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\\n                mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\\n\\n                mstore(W4_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\\n                mstore(W4_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\\n\\n                mstore(S_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\\n                mstore(S_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\\n                mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\\n                mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\\n                mstore(Z_LOOKUP_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\\n                mstore(Z_LOOKUP_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\\n                mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x1c0)), q))\\n                mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x1e0)), q))\\n\\n                mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x200)), q))\\n                mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x220)), q))\\n\\n                mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x240)), q))\\n                mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x260)), q))\\n\\n                mstore(T4_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\\n                mstore(T4_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\\n\\n                mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2c0)), p))\\n                mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2e0)), p))\\n                mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x300)), p))\\n                mstore(W4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x320)), p))\\n                mstore(S_EVAL_LOC, mod(calldataload(add(data_ptr, 0x340)), p))\\n                mstore(Z_EVAL_LOC, mod(calldataload(add(data_ptr, 0x360)), p))\\n                mstore(Z_LOOKUP_EVAL_LOC, mod(calldataload(add(data_ptr, 0x380)), p))\\n                mstore(Q1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3a0)), p))\\n                mstore(Q2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3c0)), p))\\n                mstore(Q3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3e0)), p))\\n                mstore(Q4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x400)), p))\\n                mstore(QM_EVAL_LOC, mod(calldataload(add(data_ptr, 0x420)), p))\\n                mstore(QC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x440)), p))\\n                mstore(QARITH_EVAL_LOC, mod(calldataload(add(data_ptr, 0x460)), p))\\n                mstore(QSORT_EVAL_LOC, mod(calldataload(add(data_ptr, 0x480)), p))\\n                mstore(QELLIPTIC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4a0)), p))\\n                mstore(QAUX_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4c0)), p))\\n\\n                mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4e0)), p))\\n                mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x500)), p))\\n\\n                mstore(SIGMA3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x520)), p))\\n                mstore(SIGMA4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x540)), p))\\n\\n                mstore(TABLE1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x560)), p))\\n                mstore(TABLE2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x580)), p))\\n                mstore(TABLE3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5a0)), p))\\n                mstore(TABLE4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5c0)), p))\\n                mstore(TABLE_TYPE_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5e0)), p))\\n\\n                mstore(ID1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x600)), p))\\n                mstore(ID2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x620)), p))\\n                mstore(ID3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x640)), p))\\n                mstore(ID4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x660)), p))\\n\\n                mstore(W1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x680)), p))\\n                mstore(W2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6a0)), p))\\n                mstore(W3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6c0)), p))\\n                mstore(W4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6e0)), p))\\n                mstore(S_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x700)), p))\\n\\n                mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x720)), p))\\n\\n                mstore(Z_LOOKUP_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x740)), p))\\n                mstore(TABLE1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x760)), p))\\n                mstore(TABLE2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x780)), p))\\n                mstore(TABLE3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7a0)), p))\\n                mstore(TABLE4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7c0)), p))\\n\\n                mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x7e0)), q))\\n                mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x800)), q))\\n\\n                mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x820)), q))\\n                mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x840)), q))\\n            }\\n\\n            /**\\n             * LOAD RECURSIVE PROOF INTO MEMORY\\n             */\\n            {\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n                    let index_counter := add(shl(5, mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC)), public_inputs_ptr)\\n\\n                    let x0 := calldataload(index_counter)\\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                    let y0 := calldataload(add(index_counter, 0x80))\\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                    let x1 := calldataload(add(index_counter, 0x100))\\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                    let y1 := calldataload(add(index_counter, 0x180))\\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n                    mstore(RECURSIVE_P1_X_LOC, x0)\\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\\n                    mstore(RECURSIVE_P2_X_LOC, x1)\\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\\n\\n                    // validate these are valid bn128 G1 points\\n                    if iszero(and(and(lt(x0, q), lt(x1, q)), and(lt(y0, q), lt(y1, q)))) {\\n                        mstore(0x00, PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * Generate initial challenge\\n                 */\\n                mstore(0x00, shl(224, mload(N_LOC)))\\n                mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\\n                let challenge := keccak256(0x00, 0x08)\\n\\n                /**\\n                 * Generate eta challenge\\n                 */\\n                mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\\n                // The public input location is stored at 0x24, we then add 0x24 to skip selector and the length of public inputs\\n                let public_inputs_start := add(calldataload(0x24), 0x24)\\n                // copy the public inputs over\\n                let public_input_size := mul(mload(NUM_INPUTS_LOC), 0x20)\\n                calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_inputs_start, public_input_size)\\n\\n                // copy W1, W2, W3 into challenge. Each point is 0x40 bytes, so load 0xc0 = 3 * 0x40 bytes (ETA input length)\\n                let w_start := add(calldataload(0x04), 0x24)\\n                calldatacopy(add(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_input_size), w_start, ETA_INPUT_LENGTH)\\n\\n                // Challenge is the old challenge + public inputs + W1, W2, W3 (0x20 + public_input_size + 0xc0)\\n                let challenge_bytes_size := add(0x20, add(public_input_size, ETA_INPUT_LENGTH))\\n\\n                challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, challenge_bytes_size)\\n                {\\n                    let eta := mod(challenge, p)\\n                    mstore(C_ETA_LOC, eta)\\n                    mstore(C_ETA_SQR_LOC, mulmod(eta, eta, p))\\n                    mstore(C_ETA_CUBE_LOC, mulmod(mload(C_ETA_SQR_LOC), eta, p))\\n                }\\n\\n                /**\\n                 * Generate beta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(W4_Y_LOC))\\n                mstore(0x40, mload(W4_X_LOC))\\n                mstore(0x60, mload(S_Y_LOC))\\n                mstore(0x80, mload(S_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_BETA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate gamma challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_GAMMA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate alpha challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(Z_Y_LOC))\\n                mstore(0x40, mload(Z_X_LOC))\\n                mstore(0x60, mload(Z_LOOKUP_Y_LOC))\\n                mstore(0x80, mload(Z_LOOKUP_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_ALPHA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Compute and store some powers of alpha for future computations\\n                 */\\n                let alpha := mload(C_ALPHA_LOC)\\n                mstore(C_ALPHA_SQR_LOC, mulmod(alpha, alpha, p))\\n                mstore(C_ALPHA_CUBE_LOC, mulmod(mload(C_ALPHA_SQR_LOC), alpha, p))\\n                mstore(C_ALPHA_QUAD_LOC, mulmod(mload(C_ALPHA_CUBE_LOC), alpha, p))\\n                mstore(C_ALPHA_BASE_LOC, alpha)\\n\\n                /**\\n                 * Generate zeta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(T1_Y_LOC))\\n                mstore(0x40, mload(T1_X_LOC))\\n                mstore(0x60, mload(T2_Y_LOC))\\n                mstore(0x80, mload(T2_X_LOC))\\n                mstore(0xa0, mload(T3_Y_LOC))\\n                mstore(0xc0, mload(T3_X_LOC))\\n                mstore(0xe0, mload(T4_Y_LOC))\\n                mstore(0x100, mload(T4_X_LOC))\\n\\n                challenge := keccak256(0x00, 0x120)\\n\\n                mstore(C_ZETA_LOC, mod(challenge, p))\\n                mstore(C_CURRENT_LOC, challenge)\\n            }\\n\\n            /**\\n             * EVALUATE FIELD OPERATIONS\\n             */\\n\\n            /**\\n             * COMPUTE PUBLIC INPUT DELTA\\n             * \\u0394PI = \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3(i) + \\u03b3) / \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3'(i) + \\u03b3)\\n             */\\n            {\\n                let beta := mload(C_BETA_LOC) // \\u03b2\\n                let gamma := mload(C_GAMMA_LOC) // \\u03b3\\n                let work_root := mload(OMEGA_LOC) // \\u03c9\\n                let numerator_value := 1\\n                let denominator_value := 1\\n\\n                let p_clone := p // move p to the front of the stack\\n                let valid_inputs := true\\n\\n                // Load the starting point of the public inputs (jump over the selector and the length of public inputs [0x24])\\n                let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n\\n                // endpoint_ptr = public_inputs_ptr + num_inputs * 0x20. // every public input is 0x20 bytes\\n                let endpoint_ptr := add(public_inputs_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\\n\\n                // root_1 = \\u03b2 * 0x05\\n                let root_1 := mulmod(beta, 0x05, p_clone) // k1.\\u03b2\\n                // root_2 = \\u03b2 * 0x0c\\n                let root_2 := mulmod(beta, 0x0c, p_clone)\\n                // @note 0x05 + 0x07 == 0x0c == external coset generator\\n\\n                for {} lt(public_inputs_ptr, endpoint_ptr) { public_inputs_ptr := add(public_inputs_ptr, 0x20) } {\\n                    /**\\n                     * input = public_input[i]\\n                     * valid_inputs &= input < p\\n                     * temp = input + gamma\\n                     * numerator_value *= (\\u03b2.\\u03c3(i) + w\\u1d62 + \\u03b3)  // \\u03c3(i) = 0x05.\\u03c9\\u2071\\n                     * denominator_value *= (\\u03b2.\\u03c3'(i) + w\\u1d62 + \\u03b3) // \\u03c3'(i) = 0x0c.\\u03c9\\u2071\\n                     * root_1 *= \\u03c9\\n                     * root_2 *= \\u03c9\\n                     */\\n\\n                    let input := calldataload(public_inputs_ptr)\\n                    valid_inputs := and(valid_inputs, lt(input, p_clone))\\n                    let temp := addmod(input, gamma, p_clone)\\n\\n                    numerator_value := mulmod(numerator_value, add(root_1, temp), p_clone)\\n                    denominator_value := mulmod(denominator_value, add(root_2, temp), p_clone)\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n                }\\n\\n                // Revert if not all public inputs are field elements (i.e. < p)\\n                if iszero(valid_inputs) {\\n                    mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n\\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\\n            }\\n\\n            /**\\n             * Compute Plookup delta factor [\\u03b3(1 + \\u03b2)]^{n-k}\\n             * k = num roots cut out of Z_H = 4\\n             */\\n            {\\n                let delta_base := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let delta_numerator := delta_base\\n                {\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        delta_numerator := mulmod(delta_numerator, delta_numerator, p)\\n                    }\\n                }\\n                mstore(PLOOKUP_DELTA_NUMERATOR_LOC, delta_numerator)\\n\\n                let delta_denominator := mulmod(delta_base, delta_base, p)\\n                delta_denominator := mulmod(delta_denominator, delta_denominator, p)\\n                mstore(PLOOKUP_DELTA_DENOMINATOR_LOC, delta_denominator)\\n            }\\n            /**\\n             * Compute lagrange poly and vanishing poly fractions\\n             */\\n            {\\n                /**\\n                 * vanishing_numerator = zeta\\n                 * ZETA_POW_N = zeta^n\\n                 * vanishing_numerator -= 1\\n                 * accumulating_root = omega_inverse\\n                 * work_root = p - accumulating_root\\n                 * domain_inverse = domain_inverse\\n                 * vanishing_denominator = zeta + work_root\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * vanishing_denominator *= (zeta + (zeta + accumulating_root))\\n                 * work_root = omega\\n                 * lagrange_numerator = vanishing_numerator * domain_inverse\\n                 * l_start_denominator = zeta - 1\\n                 * accumulating_root = work_root^2\\n                 * l_end_denominator = accumulating_root^2 * work_root * zeta - 1\\n                 * Note: l_end_denominator term contains a term \\\\omega^5 to cut out 5 roots of unity from vanishing poly\\n                 */\\n\\n                let zeta := mload(C_ZETA_LOC)\\n\\n                // compute zeta^n, where n is a power of 2\\n                let vanishing_numerator := zeta\\n                {\\n                    // pow_small\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\\n                    }\\n                }\\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n\\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\\n                let work_root := sub(p, accumulating_root)\\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\\n\\n                let vanishing_denominator := addmod(zeta, work_root, p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                vanishing_denominator :=\\n                    mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\\n\\n                work_root := mload(OMEGA_LOC)\\n\\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\\n\\n                accumulating_root := mulmod(work_root, work_root, p)\\n\\n                let l_end_denominator :=\\n                    addmod(\\n                        mulmod(mulmod(mulmod(accumulating_root, accumulating_root, p), work_root, p), zeta, p), sub(p, 1), p\\n                    )\\n\\n                /**\\n                 * Compute inversions using Montgomery's batch inversion trick\\n                 */\\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\\n                let t0 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n                let t1 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n                let t2 := accumulator\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n                let t3 := accumulator\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n                let t4 := accumulator\\n                {\\n                    mstore(0, 0x20)\\n                    mstore(0x20, 0x20)\\n                    mstore(0x40, 0x20)\\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\\n                    mstore(0x80, sub(p, 2))\\n                    mstore(0xa0, p)\\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20)) {\\n                        mstore(0x0, MOD_EXP_FAILURE_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                    accumulator := mload(0x00)\\n                }\\n\\n                t4 := mulmod(accumulator, t4, p)\\n                accumulator := mulmod(accumulator, l_end_denominator, p)\\n\\n                t3 := mulmod(accumulator, t3, p)\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n\\n                t2 := mulmod(accumulator, t2, p)\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n\\n                t1 := mulmod(accumulator, t1, p)\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n\\n                t0 := mulmod(accumulator, t0, p)\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n\\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\\n\\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\\n                mstore(ZERO_POLY_INVERSE_LOC, mulmod(vanishing_denominator, t1, p))\\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t2, p))\\n                mstore(PLOOKUP_DELTA_LOC, mulmod(mload(PLOOKUP_DELTA_NUMERATOR_LOC), t3, p))\\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t4, p))\\n            }\\n\\n            /**\\n             * UltraPlonk Widget Ordering:\\n             *\\n             * 1. Permutation widget\\n             * 2. Plookup widget\\n             * 3. Arithmetic widget\\n             * 4. Fixed base widget (?)\\n             * 5. GenPermSort widget\\n             * 6. Elliptic widget\\n             * 7. Auxiliary widget\\n             */\\n\\n            /**\\n             * COMPUTE PERMUTATION WIDGET EVALUATION\\n             */\\n            {\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta := mload(C_BETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n\\n                /**\\n                 * t1 = (W1 + gamma + beta * ID1) * (W2 + gamma + beta * ID2)\\n                 * t2 = (W3 + gamma + beta * ID3) * (W4 + gamma + beta * ID4)\\n                 * result = alpha_base * z_eval * t1 * t2\\n                 * t1 = (W1 + gamma + beta * sigma_1_eval) * (W2 + gamma + beta * sigma_2_eval)\\n                 * t2 = (W2 + gamma + beta * sigma_3_eval) * (W3 + gamma + beta * sigma_4_eval)\\n                 * result -= (alpha_base * z_omega_eval * t1 * t2)\\n                 */\\n                let t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(ID1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(ID2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(ID3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(ID4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let result := mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_EVAL_LOC), mulmod(t1, t2, p), p), p)\\n                t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                result :=\\n                    addmod(\\n                        result,\\n                        sub(p, mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_OMEGA_EVAL_LOC), mulmod(t1, t2, p), p), p)),\\n                        p\\n                    )\\n\\n                /**\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_{n-k}(\\u0293) . (z(\\u0293.\\u03c9) - \\u2206_{PI}))\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_1(\\u0293)(Z(\\u0293) - 1))\\n                 * alpha_Base *= alpha\\n                 */\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                result :=\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(\\n                                mload(L_END_LOC),\\n                                addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                mstore(\\n                    PERMUTATION_IDENTITY,\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(mload(L_START_LOC), addmod(mload(Z_EVAL_LOC), sub(p, 1), p), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE PLOOKUP WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * Goal: f = (w1(z) + q2.w1(z\\u03c9)) + \\u03b7(w2(z) + qm.w2(z\\u03c9)) + \\u03b7\\u00b2(w3(z) + qc.w_3(z\\u03c9)) + q3(z).\\u03b7\\u00b3\\n                 * f = \\u03b7.q3(z)\\n                 * f += (w3(z) + qc.w_3(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w2(z) + qm.w2(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w1(z) + q2.w1(z\\u03c9))\\n                 */\\n                let f := mulmod(mload(C_ETA_LOC), mload(Q3_EVAL_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W3_EVAL_LOC), mulmod(mload(QC_EVAL_LOC), mload(W3_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W2_EVAL_LOC), mulmod(mload(QM_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W1_EVAL_LOC), mulmod(mload(Q2_EVAL_LOC), mload(W1_OMEGA_EVAL_LOC), p), p), p)\\n\\n                // t(z) = table4(z).\\u03b7\\u00b3 + table3(z).\\u03b7\\u00b2 + table2(z).\\u03b7 + table1(z)\\n                let t :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_EVAL_LOC),\\n                        p\\n                    )\\n\\n                // t(zw) = table4(zw).\\u03b7\\u00b3 + table3(zw).\\u03b7\\u00b2 + table2(zw).\\u03b7 + table1(zw)\\n                let t_omega :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_OMEGA_EVAL_LOC),\\n                        p\\n                    )\\n\\n                /**\\n                 * Goal: numerator = (TABLE_TYPE_EVAL * f(z) + \\u03b3) * (t(z) + \\u03b2t(z\\u03c9) + \\u03b3(\\u03b2 + 1)) * (\\u03b2 + 1)\\n                 * gamma_beta_constant = \\u03b3(\\u03b2 + 1)\\n                 * numerator = f * TABLE_TYPE_EVAL + gamma\\n                 * temp0 = t(z) + t(z\\u03c9) * \\u03b2 + gamma_beta_constant\\n                 * numerator *= temp0\\n                 * numerator *= (\\u03b2 + 1)\\n                 * temp0 = alpha * l_1\\n                 * numerator += temp0\\n                 * numerator *= z_lookup(z)\\n                 * numerator -= temp0\\n                 */\\n                let gamma_beta_constant := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let numerator := addmod(mulmod(f, mload(TABLE_TYPE_EVAL_LOC), p), mload(C_GAMMA_LOC), p)\\n                let temp0 := addmod(addmod(t, mulmod(t_omega, mload(C_BETA_LOC), p), p), gamma_beta_constant, p)\\n                numerator := mulmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, addmod(mload(C_BETA_LOC), 1, p), p)\\n                temp0 := mulmod(mload(C_ALPHA_LOC), mload(L_START_LOC), p)\\n                numerator := addmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, mload(Z_LOOKUP_EVAL_LOC), p)\\n                numerator := addmod(numerator, sub(p, temp0), p)\\n\\n                /**\\n                 * Goal: denominator = z_lookup(z\\u03c9)*[s(z) + \\u03b2s(z\\u03c9) + \\u03b3(1 + \\u03b2)] - [z_lookup(z\\u03c9) - [\\u03b3(1 + \\u03b2)]^{n-k}]*\\u03b1\\u00b2L_end(z)\\n                 * note: delta_factor = [\\u03b3(1 + \\u03b2)]^{n-k}\\n                 * denominator = s(z) + \\u03b2s(z\\u03c9) + \\u03b3(\\u03b2 + 1)\\n                 * temp1 = \\u03b1\\u00b2L_end(z)\\n                 * denominator -= temp1\\n                 * denominator *= z_lookup(z\\u03c9)\\n                 * denominator += temp1 * delta_factor\\n                 * PLOOKUP_IDENTITY = (numerator - denominator).alpha_base\\n                 * alpha_base *= alpha^3\\n                 */\\n                let denominator :=\\n                    addmod(\\n                        addmod(mload(S_EVAL_LOC), mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_BETA_LOC), p), p),\\n                        gamma_beta_constant,\\n                        p\\n                    )\\n                let temp1 := mulmod(mload(C_ALPHA_SQR_LOC), mload(L_END_LOC), p)\\n                denominator := addmod(denominator, sub(p, temp1), p)\\n                denominator := mulmod(denominator, mload(Z_LOOKUP_OMEGA_EVAL_LOC), p)\\n                denominator := addmod(denominator, mulmod(temp1, mload(PLOOKUP_DELTA_LOC), p), p)\\n\\n                mstore(PLOOKUP_IDENTITY, mulmod(addmod(numerator, sub(p, denominator), p), mload(C_ALPHA_BASE_LOC), p))\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ARITHMETIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * The basic arithmetic gate identity in standard plonk is as follows.\\n                 * (w_1 . w_2 . q_m) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c = 0\\n                 * However, for Ultraplonk, we extend this to support \\\"passing\\\" wires between rows (shown without alpha scaling below):\\n                 * q_arith * ( ( (-1/2) * (q_arith - 3) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c ) +\\n                 * (q_arith - 1)*( \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m) + w_4_omega) ) = 0\\n                 *\\n                 * This formula results in several cases depending on q_arith:\\n                 * 1. q_arith == 0: Arithmetic gate is completely disabled\\n                 *\\n                 * 2. q_arith == 1: Everything in the minigate on the right is disabled. The equation is just a standard plonk equation\\n                 * with extra wires: q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c = 0\\n                 *\\n                 * 3. q_arith == 2: The (w_1 + w_4 - ...) term is disabled. THe equation is:\\n                 * (1/2) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + w_4_omega = 0\\n                 * It allows defining w_4 at next index (w_4_omega) in terms of current wire values\\n                 *\\n                 * 4. q_arith == 3: The product of w_1 and w_2 is disabled, but a mini addition gate is enabled. \\u03b1 allows us to split\\n                 * the equation into two:\\n                 *\\n                 * q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + 2 * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0  (we are reusing q_m here)\\n                 *\\n                 * 5. q_arith > 3: The product of w_1 and w_2 is scaled by (q_arith - 3), while the w_4_omega term is scaled by (q_arith - 1).\\n                 * The equation can be split into two:\\n                 *\\n                 * (q_arith - 3)* q_m * w_1 * w_ 2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + (q_arith - 1) * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0\\n                 *\\n                 * The problem that q_m is used both in both equations can be dealt with by appropriately changing selector values at\\n                 * the next gate. Then we can treat (q_arith - 1) as a simulated q_6 selector and scale q_m to handle (q_arith - 3) at\\n                 * product.\\n                 */\\n\\n                let w1q1 := mulmod(mload(W1_EVAL_LOC), mload(Q1_EVAL_LOC), p)\\n                let w2q2 := mulmod(mload(W2_EVAL_LOC), mload(Q2_EVAL_LOC), p)\\n                let w3q3 := mulmod(mload(W3_EVAL_LOC), mload(Q3_EVAL_LOC), p)\\n                let w4q3 := mulmod(mload(W4_EVAL_LOC), mload(Q4_EVAL_LOC), p)\\n\\n                // @todo - Add a explicit test that hits QARITH == 3\\n                // w1w2qm := (w_1 . w_2 . q_m . (QARITH_EVAL_LOC - 3)) / 2\\n                let w1w2qm :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(mulmod(mload(W1_EVAL_LOC), mload(W2_EVAL_LOC), p), mload(QM_EVAL_LOC), p),\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 3), p),\\n                            p\\n                        ),\\n                        NEGATIVE_INVERSE_OF_2_MODULO_P,\\n                        p\\n                    )\\n\\n                // (w_1 . w_2 . q_m . (q_arith - 3)) / -2) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c\\n                let identity :=\\n                    addmod(\\n                        mload(QC_EVAL_LOC), addmod(w4q3, addmod(w3q3, addmod(w2q2, addmod(w1q1, w1w2qm, p), p), p), p), p\\n                    )\\n\\n                // if q_arith == 3 we evaluate an additional mini addition gate (on top of the regular one), where:\\n                // w_1 + w_4 - w_1_omega + q_m = 0\\n                // we use this gate to save an addition gate when adding or subtracting non-native field elements\\n                // \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m)\\n                let extra_small_addition_gate_identity :=\\n                    mulmod(\\n                        mload(C_ALPHA_LOC),\\n                        mulmod(\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 2), p),\\n                            addmod(\\n                                mload(QM_EVAL_LOC),\\n                                addmod(\\n                                    sub(p, mload(W1_OMEGA_EVAL_LOC)), addmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p), p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                // if q_arith == 2 OR q_arith == 3 we add the 4th wire of the NEXT gate into the arithmetic identity\\n                // N.B. if q_arith > 2, this wire value will be scaled by (q_arith - 1) relative to the other gate wires!\\n                // alpha_base * q_arith * (identity + (q_arith - 1) * (w_4_omega + extra_small_addition_gate_identity))\\n                mstore(\\n                    ARITHMETIC_IDENTITY,\\n                    mulmod(\\n                        mload(C_ALPHA_BASE_LOC),\\n                        mulmod(\\n                            mload(QARITH_EVAL_LOC),\\n                            addmod(\\n                                identity,\\n                                mulmod(\\n                                    addmod(mload(QARITH_EVAL_LOC), sub(p, 1), p),\\n                                    addmod(mload(W4_OMEGA_EVAL_LOC), extra_small_addition_gate_identity, p),\\n                                    p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE GENPERMSORT WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * D1 = (w2 - w1)\\n                 * D2 = (w3 - w2)\\n                 * D3 = (w4 - w3)\\n                 * D4 = (w1_omega - w4)\\n                 *\\n                 * \\u03b1_a = alpha_base\\n                 * \\u03b1_b = alpha_base * \\u03b1\\n                 * \\u03b1_c = alpha_base * \\u03b1^2\\n                 * \\u03b1_d = alpha_base * \\u03b1^3\\n                 *\\n                 * range_accumulator = (\\n                 *   D1(D1 - 1)(D1 - 2)(D1 - 3).\\u03b1_a +\\n                 *   D2(D2 - 1)(D2 - 2)(D2 - 3).\\u03b1_b +\\n                 *   D3(D3 - 1)(D3 - 2)(D3 - 3).\\u03b1_c +\\n                 *   D4(D4 - 1)(D4 - 2)(D4 - 3).\\u03b1_d +\\n                 * ) . q_sort\\n                 */\\n                let minus_two := sub(p, 2)\\n                let minus_three := sub(p, 3)\\n                let d1 := addmod(mload(W2_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                let d2 := addmod(mload(W3_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n                let d3 := addmod(mload(W4_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                let d4 := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                let range_accumulator :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(addmod(mulmod(d1, d1, p), sub(p, d1), p), addmod(d1, minus_two, p), p),\\n                            addmod(d1, minus_three, p),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d2, d2, p), sub(p, d2), p), addmod(d2, minus_two, p), p),\\n                                addmod(d2, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d3, d3, p), sub(p, d3), p), addmod(d3, minus_two, p), p),\\n                                addmod(d3, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d4, d4, p), sub(p, d4), p), addmod(d4, minus_two, p), p),\\n                                addmod(d4, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator := mulmod(range_accumulator, mload(QSORT_EVAL_LOC), p)\\n\\n                mstore(SORT_IDENTITY, range_accumulator)\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ELLIPTIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * endo_term = (-x_2) * x_1 * (x_3 * 2 + x_1) * q_beta\\n                 * endo_sqr_term = x_2^2\\n                 * endo_sqr_term *= (x_3 - x_1)\\n                 * endo_sqr_term *= q_beta^2\\n                 * leftovers = x_2^2\\n                 * leftovers *= x_2\\n                 * leftovers += x_1^2 * (x_3 + x_1) @follow-up Invalid comment in BB widget\\n                 * leftovers -= (y_2^2 + y_1^2)\\n                 * sign_term = y_2 * y_1\\n                 * sign_term += sign_term\\n                 * sign_term *= q_sign\\n                 */\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let x_diff := addmod(mload(X2_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p)\\n                let y2_sqr := mulmod(mload(Y2_EVAL_LOC), mload(Y2_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let y1y2 := mulmod(mulmod(mload(Y1_EVAL_LOC), mload(Y2_EVAL_LOC), p), mload(QSIGN_LOC), p)\\n\\n                let x_add_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X2_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            mulmod(x_diff, x_diff, p),\\n                            p\\n                        ),\\n                        addmod(\\n                            sub(\\n                                p,\\n                                addmod(y2_sqr, y1_sqr, p)\\n                            ),\\n                            addmod(y1y2, y1y2, p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                x_add_identity :=\\n                    mulmod(\\n                        mulmod(\\n                            x_add_identity,\\n                            addmod(\\n                                1,\\n                                sub(p, mload(QM_EVAL_LOC)),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let y1_plus_y3 := addmod(\\n                    mload(Y1_EVAL_LOC),\\n                    mload(Y3_EVAL_LOC),\\n                    p\\n                )\\n                let y_diff := addmod(mulmod(mload(Y2_EVAL_LOC), mload(QSIGN_LOC), p), sub(p, mload(Y1_EVAL_LOC)), p)\\n                let y_add_identity :=\\n                    addmod(\\n                        mulmod(y1_plus_y3, x_diff, p),\\n                        mulmod(addmod(mload(X3_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p), y_diff, p),\\n                        p\\n                    )\\n                y_add_identity :=\\n                    mulmod(\\n                        mulmod(y_add_identity, addmod(1, sub(p, mload(QM_EVAL_LOC)), p), p),\\n                        mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                        p\\n                    )\\n\\n                // ELLIPTIC_IDENTITY = (x_identity + y_identity) * Q_ELLIPTIC_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY, mulmod(addmod(x_add_identity, y_add_identity, p), mload(QELLIPTIC_EVAL_LOC), p)\\n                )\\n            }\\n            {\\n                /**\\n                 * x_pow_4 = (y_1_sqr - curve_b) * x_1;\\n                 * y_1_sqr_mul_4 = y_1_sqr + y_1_sqr;\\n                 * y_1_sqr_mul_4 += y_1_sqr_mul_4;\\n                 * x_1_pow_4_mul_9 = x_pow_4;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_pow_4;\\n                 * x_1_sqr_mul_3 = x_1_sqr + x_1_sqr + x_1_sqr;\\n                 * x_double_identity = (x_3 + x_1 + x_1) * y_1_sqr_mul_4 - x_1_pow_4_mul_9;\\n                 * y_double_identity = x_1_sqr_mul_3 * (x_1 - x_3) - (y_1 + y_1) * (y_1 + y_3);\\n                 */\\n                // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n                let x1_sqr := mulmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let x_pow_4 := mulmod(addmod(y1_sqr, GRUMPKIN_CURVE_B_PARAMETER_NEGATED, p), mload(X1_EVAL_LOC), p)\\n                let y1_sqr_mul_4 := mulmod(y1_sqr, 4, p)\\n                let x1_pow_4_mul_9 := mulmod(x_pow_4, 9, p)\\n                let x1_sqr_mul_3 := mulmod(x1_sqr, 3, p)\\n                let x_double_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            y1_sqr_mul_4,\\n                            p\\n                        ),\\n                        sub(p, x1_pow_4_mul_9),\\n                        p\\n                    )\\n                // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n                let y_double_identity :=\\n                    addmod(\\n                        mulmod(x1_sqr_mul_3, addmod(mload(X1_EVAL_LOC), sub(p, mload(X3_EVAL_LOC)), p), p),\\n                        sub(\\n                            p,\\n                            mulmod(\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p),\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y3_EVAL_LOC), p),\\n                                p\\n                            )\\n                        ),\\n                        p\\n                    )\\n                x_double_identity := mulmod(x_double_identity, mload(C_ALPHA_BASE_LOC), p)\\n                y_double_identity :=\\n                    mulmod(y_double_identity, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p), p)\\n                x_double_identity := mulmod(x_double_identity, mload(QM_EVAL_LOC), p)\\n                y_double_identity := mulmod(y_double_identity, mload(QM_EVAL_LOC), p)\\n                // ELLIPTIC_IDENTITY += (x_double_identity + y_double_identity) * Q_DOUBLE_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY,\\n                    addmod(\\n                        mload(ELLIPTIC_IDENTITY),\\n                        mulmod(addmod(x_double_identity, y_double_identity, p), mload(QELLIPTIC_EVAL_LOC), p),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE AUXILIARY WIDGET EVALUATION\\n             */\\n            {\\n                {\\n                    /**\\n                     * Non native field arithmetic gate 2\\n                     *             _                                                                               _\\n                     *            /   _                   _                               _       14                \\\\\\n                     * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n                     *            \\\\_                                                                               _/\\n                     *\\n                     * limb_subproduct = w_1 . w_2_omega + w_1_omega . w_2\\n                     * non_native_field_gate_2 = w_1 * w_4 + w_4 * w_3 - w_3_omega\\n                     * non_native_field_gate_2 = non_native_field_gate_2 * limb_size\\n                     * non_native_field_gate_2 -= w_4_omega\\n                     * non_native_field_gate_2 += limb_subproduct\\n                     * non_native_field_gate_2 *= q_4\\n                     * limb_subproduct *= limb_size\\n                     * limb_subproduct += w_1_omega * w_2_omega\\n                     * non_native_field_gate_1 = (limb_subproduct + w_3 + w_4) * q_3\\n                     * non_native_field_gate_3 = (limb_subproduct + w_4 - (w_3_omega + w_4_omega)) * q_m\\n                     * non_native_field_identity = (non_native_field_gate_1 + non_native_field_gate_2 + non_native_field_gate_3) * q_2\\n                     */\\n\\n                    let limb_subproduct :=\\n                        addmod(\\n                            mulmod(mload(W1_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p),\\n                            mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_EVAL_LOC), p),\\n                            p\\n                        )\\n\\n                    let non_native_field_gate_2 :=\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p),\\n                                mulmod(mload(W2_EVAL_LOC), mload(W3_EVAL_LOC), p),\\n                                p\\n                            ),\\n                            sub(p, mload(W3_OMEGA_EVAL_LOC)),\\n                            p\\n                        )\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, LIMB_SIZE, p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, limb_subproduct, p)\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, mload(Q4_EVAL_LOC), p)\\n                    limb_subproduct := mulmod(limb_subproduct, LIMB_SIZE, p)\\n                    limb_subproduct :=\\n                        addmod(limb_subproduct, mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p)\\n                    let non_native_field_gate_1 :=\\n                        mulmod(\\n                            addmod(limb_subproduct, sub(p, addmod(mload(W3_EVAL_LOC), mload(W4_EVAL_LOC), p)), p),\\n                            mload(Q3_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_gate_3 :=\\n                        mulmod(\\n                            addmod(\\n                                addmod(limb_subproduct, mload(W4_EVAL_LOC), p),\\n                                sub(p, addmod(mload(W3_OMEGA_EVAL_LOC), mload(W4_OMEGA_EVAL_LOC), p)),\\n                                p\\n                            ),\\n                            mload(QM_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_identity :=\\n                        mulmod(\\n                            addmod(addmod(non_native_field_gate_1, non_native_field_gate_2, p), non_native_field_gate_3, p),\\n                            mload(Q2_EVAL_LOC),\\n                            p\\n                        )\\n\\n                    mstore(AUX_NON_NATIVE_FIELD_EVALUATION, non_native_field_identity)\\n                }\\n\\n                {\\n                    /**\\n                     * limb_accumulator_1 = w_2_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_3;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_2;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1;\\n                     * limb_accumulator_1 -= w_4;\\n                     * limb_accumulator_1 *= q_4;\\n                     */\\n                    let limb_accumulator_1 := mulmod(mload(W2_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W2_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_EVAL_LOC), p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, sub(p, mload(W4_EVAL_LOC)), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, mload(Q4_EVAL_LOC), p)\\n\\n                    /**\\n                     * limb_accumulator_2 = w_3_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_2_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_1_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_4;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_3;\\n                     * limb_accumulator_2 -= w_4_omega;\\n                     * limb_accumulator_2 *= q_m;\\n                     */\\n                    let limb_accumulator_2 := mulmod(mload(W3_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W2_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W4_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, mload(QM_EVAL_LOC), p)\\n\\n                    mstore(\\n                        AUX_LIMB_ACCUMULATOR_EVALUATION,\\n                        mulmod(addmod(limb_accumulator_1, limb_accumulator_2, p), mload(Q3_EVAL_LOC), p)\\n                    )\\n                }\\n\\n                {\\n                    /**\\n                     * memory_record_check = w_3;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_2;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_1;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += q_c;\\n                     *\\n                     * partial_record_check = memory_record_check;\\n                     *\\n                     * memory_record_check -= w_4;\\n                     */\\n\\n                    let memory_record_check := mulmod(mload(W3_EVAL_LOC), mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W2_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W1_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(QC_EVAL_LOC), p)\\n\\n                    let partial_record_check := memory_record_check\\n                    memory_record_check := addmod(memory_record_check, sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                    mstore(AUX_MEMORY_EVALUATION, memory_record_check)\\n\\n                    // index_delta = w_1_omega - w_1\\n                    let index_delta := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                    // record_delta = w_4_omega - w_4\\n                    let record_delta := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n                    // index_is_monotonically_increasing = index_delta * (index_delta - 1)\\n                    let index_is_monotonically_increasing := mulmod(index_delta, addmod(index_delta, sub(p, 1), p), p)\\n\\n                    // adjacent_values_match_if_adjacent_indices_match = record_delta * (1 - index_delta)\\n                    let adjacent_values_match_if_adjacent_indices_match :=\\n                        mulmod(record_delta, addmod(1, sub(p, index_delta), p), p)\\n\\n                    // AUX_ROM_CONSISTENCY_EVALUATION = ((adjacent_values_match_if_adjacent_indices_match * alpha) + index_is_monotonically_increasing) * alpha + partial_record_check\\n                    mstore(\\n                        AUX_ROM_CONSISTENCY_EVALUATION,\\n                        addmod(\\n                            mulmod(\\n                                addmod(\\n                                    mulmod(adjacent_values_match_if_adjacent_indices_match, mload(C_ALPHA_LOC), p),\\n                                    index_is_monotonically_increasing,\\n                                    p\\n                                ),\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            ),\\n                            memory_record_check,\\n                            p\\n                        )\\n                    )\\n\\n                    {\\n                        /**\\n                         * next_gate_access_type = w_3_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_2_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_1_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type = w_4_omega - next_gate_access_type;\\n                         */\\n                        let next_gate_access_type := mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W2_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W1_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, next_gate_access_type), p)\\n\\n                        // value_delta = w_3_omega - w_3\\n                        let value_delta := addmod(mload(W3_OMEGA_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                        //  adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (1 - index_delta) * value_delta * (1 - next_gate_access_type);\\n\\n                        let adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation :=\\n                            mulmod(\\n                                addmod(1, sub(p, index_delta), p),\\n                                mulmod(value_delta, addmod(1, sub(p, next_gate_access_type), p), p),\\n                                p\\n                            )\\n\\n                        // AUX_RAM_CONSISTENCY_EVALUATION\\n\\n                        /**\\n                         * access_type = w_4 - partial_record_check\\n                         * access_check = access_type^2 - access_type\\n                         * next_gate_access_type_is_boolean = next_gate_access_type^2 - next_gate_access_type\\n                         * RAM_consistency_check_identity = adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += index_is_monotonically_increasing;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += next_gate_access_type_is_boolean;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += access_check;\\n                         */\\n\\n                        let access_type := addmod(mload(W4_EVAL_LOC), sub(p, partial_record_check), p)\\n                        let access_check := mulmod(access_type, addmod(access_type, sub(p, 1), p), p)\\n                        let next_gate_access_type_is_boolean :=\\n                            mulmod(next_gate_access_type, addmod(next_gate_access_type, sub(p, 1), p), p)\\n                        let RAM_cci :=\\n                            mulmod(\\n                                adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation,\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            )\\n                        RAM_cci := addmod(RAM_cci, index_is_monotonically_increasing, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, next_gate_access_type_is_boolean, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, access_check, p)\\n\\n                        mstore(AUX_RAM_CONSISTENCY_EVALUATION, RAM_cci)\\n                    }\\n\\n                    {\\n                        // timestamp_delta = w_2_omega - w_2\\n                        let timestamp_delta := addmod(mload(W2_OMEGA_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n\\n                        // RAM_timestamp_check_identity = (1 - index_delta) * timestamp_delta - w_3\\n                        let RAM_timestamp_check_identity :=\\n                            addmod(\\n                                mulmod(timestamp_delta, addmod(1, sub(p, index_delta), p), p), sub(p, mload(W3_EVAL_LOC)), p\\n                            )\\n\\n                        /**\\n                         * memory_identity = ROM_consistency_check_identity * q_2;\\n                         * memory_identity += RAM_timestamp_check_identity * q_4;\\n                         * memory_identity += memory_record_check * q_m;\\n                         * memory_identity *= q_1;\\n                         * memory_identity += (RAM_consistency_check_identity * q_arith);\\n                         *\\n                         * auxiliary_identity = memory_identity + non_native_field_identity + limb_accumulator_identity;\\n                         * auxiliary_identity *= q_aux;\\n                         * auxiliary_identity *= alpha_base;\\n                         */\\n                        let memory_identity := mulmod(mload(AUX_ROM_CONSISTENCY_EVALUATION), mload(Q2_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(RAM_timestamp_check_identity, mload(Q4_EVAL_LOC), p), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(mload(AUX_MEMORY_EVALUATION), mload(QM_EVAL_LOC), p), p)\\n                        memory_identity := mulmod(memory_identity, mload(Q1_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(\\n                                memory_identity, mulmod(mload(AUX_RAM_CONSISTENCY_EVALUATION), mload(QARITH_EVAL_LOC), p), p\\n                            )\\n\\n                        let auxiliary_identity := addmod(memory_identity, mload(AUX_NON_NATIVE_FIELD_EVALUATION), p)\\n                        auxiliary_identity := addmod(auxiliary_identity, mload(AUX_LIMB_ACCUMULATOR_EVALUATION), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(QAUX_EVAL_LOC), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(C_ALPHA_BASE_LOC), p)\\n\\n                        mstore(AUX_IDENTITY, auxiliary_identity)\\n\\n                        // update alpha\\n                        mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * quotient = ARITHMETIC_IDENTITY\\n                 * quotient += PERMUTATION_IDENTITY\\n                 * quotient += PLOOKUP_IDENTITY\\n                 * quotient += SORT_IDENTITY\\n                 * quotient += ELLIPTIC_IDENTITY\\n                 * quotient += AUX_IDENTITY\\n                 * quotient *= ZERO_POLY_INVERSE\\n                 */\\n                mstore(\\n                    QUOTIENT_EVAL_LOC,\\n                    mulmod(\\n                        addmod(\\n                            addmod(\\n                                addmod(\\n                                    addmod(\\n                                        addmod(mload(PERMUTATION_IDENTITY), mload(PLOOKUP_IDENTITY), p),\\n                                        mload(ARITHMETIC_IDENTITY),\\n                                        p\\n                                    ),\\n                                    mload(SORT_IDENTITY),\\n                                    p\\n                                ),\\n                                mload(ELLIPTIC_IDENTITY),\\n                                p\\n                            ),\\n                            mload(AUX_IDENTITY),\\n                            p\\n                        ),\\n                        mload(ZERO_POLY_INVERSE_LOC),\\n                        p\\n                    )\\n                )\\n            }\\n\\n            /**\\n             * GENERATE NU AND SEPARATOR CHALLENGES\\n             */\\n            {\\n                let current_challenge := mload(C_CURRENT_LOC)\\n                // get a calldata pointer that points to the start of the data we want to copy\\n                let calldata_ptr := add(calldataload(0x04), 0x24)\\n\\n                calldata_ptr := add(calldata_ptr, NU_CALLDATA_SKIP_LENGTH)\\n\\n                mstore(NU_CHALLENGE_INPUT_LOC_A, current_challenge)\\n                mstore(NU_CHALLENGE_INPUT_LOC_B, mload(QUOTIENT_EVAL_LOC))\\n                calldatacopy(NU_CHALLENGE_INPUT_LOC_C, calldata_ptr, NU_INPUT_LENGTH)\\n\\n                // hash length = (0x20 + num field elements), we include the previous challenge in the hash\\n                let challenge := keccak256(NU_CHALLENGE_INPUT_LOC_A, add(NU_INPUT_LENGTH, 0x40))\\n\\n                mstore(C_V0_LOC, mod(challenge, p))\\n                // We need THIRTY-ONE independent nu challenges!\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x02)\\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x03)\\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x04)\\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x05)\\n                mstore(C_V5_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x06)\\n                mstore(C_V6_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x07)\\n                mstore(C_V7_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x08)\\n                mstore(C_V8_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x09)\\n                mstore(C_V9_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0a)\\n                mstore(C_V10_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0b)\\n                mstore(C_V11_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0c)\\n                mstore(C_V12_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0d)\\n                mstore(C_V13_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0e)\\n                mstore(C_V14_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0f)\\n                mstore(C_V15_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x10)\\n                mstore(C_V16_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x11)\\n                mstore(C_V17_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x12)\\n                mstore(C_V18_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x13)\\n                mstore(C_V19_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x14)\\n                mstore(C_V20_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x15)\\n                mstore(C_V21_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x16)\\n                mstore(C_V22_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x17)\\n                mstore(C_V23_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x18)\\n                mstore(C_V24_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x19)\\n                mstore(C_V25_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1a)\\n                mstore(C_V26_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1b)\\n                mstore(C_V27_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1c)\\n                mstore(C_V28_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1d)\\n                mstore(C_V29_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                // @follow-up - Why are both v29 and v30 using appending 0x1d to the prior challenge and hashing, should it not change?\\n                mstore8(0x20, 0x1d)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_V30_LOC, mod(challenge, p))\\n\\n                // separator\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\\n\\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\\n            }\\n\\n            let success := 0\\n            // VALIDATE T1\\n            {\\n                let x := mload(T1_X_LOC)\\n                let y := mload(T1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                mstore(ACCUMULATOR_X_LOC, x)\\n                mstore(add(ACCUMULATOR_X_LOC, 0x20), y)\\n            }\\n            // VALIDATE T2\\n            {\\n                let x := mload(T2_X_LOC) // 0x1400\\n                let y := mload(T2_Y_LOC) // 0x1420\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(ZETA_POW_N_LOC))\\n            // accumulator_2 = [T2].zeta^n\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = [T1] + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T3\\n            {\\n                let x := mload(T3_X_LOC)\\n                let y := mload(T3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T3].zeta^{2n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T4\\n            {\\n                let x := mload(T4_X_LOC)\\n                let y := mload(T4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T4].zeta^{3n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W1\\n            {\\n                let x := mload(W1_X_LOC)\\n                let y := mload(W1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V0_LOC), p))\\n            // accumulator_2 = v0.(u + 1).[W1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W2\\n            {\\n                let x := mload(W2_X_LOC)\\n                let y := mload(W2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V1_LOC), p))\\n            // accumulator_2 = v1.(u + 1).[W2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W3\\n            {\\n                let x := mload(W3_X_LOC)\\n                let y := mload(W3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V2_LOC), p))\\n            // accumulator_2 = v2.(u + 1).[W3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W4\\n            {\\n                let x := mload(W4_X_LOC)\\n                let y := mload(W4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V3_LOC), p))\\n            // accumulator_2 = v3.(u + 1).[W4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE S\\n            {\\n                let x := mload(S_X_LOC)\\n                let y := mload(S_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V4_LOC), p))\\n            // accumulator_2 = v4.(u + 1).[S]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z\\n            {\\n                let x := mload(Z_X_LOC)\\n                let y := mload(Z_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V5_LOC), p))\\n            // accumulator_2 = v5.(u + 1).[Z]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z_LOOKUP\\n            {\\n                let x := mload(Z_LOOKUP_X_LOC)\\n                let y := mload(Z_LOOKUP_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V6_LOC), p))\\n            // accumulator_2 = v6.(u + 1).[Z_LOOKUP]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q1\\n            {\\n                let x := mload(Q1_X_LOC)\\n                let y := mload(Q1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V7_LOC))\\n            // accumulator_2 = v7.[Q1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q2\\n            {\\n                let x := mload(Q2_X_LOC)\\n                let y := mload(Q2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V8_LOC))\\n            // accumulator_2 = v8.[Q2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q3\\n            {\\n                let x := mload(Q3_X_LOC)\\n                let y := mload(Q3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V9_LOC))\\n            // accumulator_2 = v9.[Q3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q4\\n            {\\n                let x := mload(Q4_X_LOC)\\n                let y := mload(Q4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V10_LOC))\\n            // accumulator_2 = v10.[Q4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QM\\n            {\\n                let x := mload(QM_X_LOC)\\n                let y := mload(QM_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V11_LOC))\\n            // accumulator_2 = v11.[Q;]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QC\\n            {\\n                let x := mload(QC_X_LOC)\\n                let y := mload(QC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V12_LOC))\\n            // accumulator_2 = v12.[QC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QARITH\\n            {\\n                let x := mload(QARITH_X_LOC)\\n                let y := mload(QARITH_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V13_LOC))\\n            // accumulator_2 = v13.[QARITH]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QSORT\\n            {\\n                let x := mload(QSORT_X_LOC)\\n                let y := mload(QSORT_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V14_LOC))\\n            // accumulator_2 = v14.[QSORT]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QELLIPTIC\\n            {\\n                let x := mload(QELLIPTIC_X_LOC)\\n                let y := mload(QELLIPTIC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V15_LOC))\\n            // accumulator_2 = v15.[QELLIPTIC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QAUX\\n            {\\n                let x := mload(QAUX_X_LOC)\\n                let y := mload(QAUX_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V16_LOC))\\n            // accumulator_2 = v15.[Q_AUX]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA1\\n            {\\n                let x := mload(SIGMA1_X_LOC)\\n                let y := mload(SIGMA1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V17_LOC))\\n            // accumulator_2 = v17.[sigma1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA2\\n            {\\n                let x := mload(SIGMA2_X_LOC)\\n                let y := mload(SIGMA2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V18_LOC))\\n            // accumulator_2 = v18.[sigma2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA3\\n            {\\n                let x := mload(SIGMA3_X_LOC)\\n                let y := mload(SIGMA3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V19_LOC))\\n            // accumulator_2 = v19.[sigma3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA4\\n            {\\n                let x := mload(SIGMA4_X_LOC)\\n                let y := mload(SIGMA4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V20_LOC))\\n            // accumulator_2 = v20.[sigma4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE1\\n            {\\n                let x := mload(TABLE1_X_LOC)\\n                let y := mload(TABLE1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V21_LOC), p))\\n            // accumulator_2 = u.[table1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE2\\n            {\\n                let x := mload(TABLE2_X_LOC)\\n                let y := mload(TABLE2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V22_LOC), p))\\n            // accumulator_2 = u.[table2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE3\\n            {\\n                let x := mload(TABLE3_X_LOC)\\n                let y := mload(TABLE3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V23_LOC), p))\\n            // accumulator_2 = u.[table3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE4\\n            {\\n                let x := mload(TABLE4_X_LOC)\\n                let y := mload(TABLE4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V24_LOC), p))\\n            // accumulator_2 = u.[table4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE_TYPE\\n            {\\n                let x := mload(TABLE_TYPE_X_LOC)\\n                let y := mload(TABLE_TYPE_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V25_LOC))\\n            // accumulator_2 = v25.[TableType]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID1\\n            {\\n                let x := mload(ID1_X_LOC)\\n                let y := mload(ID1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V26_LOC))\\n            // accumulator_2 = v26.[ID1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID2\\n            {\\n                let x := mload(ID2_X_LOC)\\n                let y := mload(ID2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V27_LOC))\\n            // accumulator_2 = v27.[ID2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID3\\n            {\\n                let x := mload(ID3_X_LOC)\\n                let y := mload(ID3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V28_LOC))\\n            // accumulator_2 = v28.[ID3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID4\\n            {\\n                let x := mload(ID4_X_LOC)\\n                let y := mload(ID4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V29_LOC))\\n            // accumulator_2 = v29.[ID4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            /**\\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\\n             */\\n            {\\n                /**\\n                 * batch_evaluation = v0 * (w_1_omega * u + w_1_eval)\\n                 * batch_evaluation += v1 * (w_2_omega * u + w_2_eval)\\n                 * batch_evaluation += v2 * (w_3_omega * u + w_3_eval)\\n                 * batch_evaluation += v3 * (w_4_omega * u + w_4_eval)\\n                 * batch_evaluation += v4 * (s_omega_eval * u + s_eval)\\n                 * batch_evaluation += v5 * (z_omega_eval * u + z_eval)\\n                 * batch_evaluation += v6 * (z_lookup_omega_eval * u + z_lookup_eval)\\n                 */\\n                let batch_evaluation :=\\n                    mulmod(\\n                        mload(C_V0_LOC),\\n                        addmod(mulmod(mload(W1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W1_EVAL_LOC), p),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V1_LOC),\\n                            addmod(mulmod(mload(W2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V2_LOC),\\n                            addmod(mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V3_LOC),\\n                            addmod(mulmod(mload(W4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V4_LOC),\\n                            addmod(mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(S_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V5_LOC),\\n                            addmod(mulmod(mload(Z_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V6_LOC),\\n                            addmod(mulmod(mload(Z_LOOKUP_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_LOOKUP_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                /**\\n                 * batch_evaluation += v7 * Q1_EVAL\\n                 * batch_evaluation += v8 * Q2_EVAL\\n                 * batch_evaluation += v9 * Q3_EVAL\\n                 * batch_evaluation += v10 * Q4_EVAL\\n                 * batch_evaluation += v11 * QM_EVAL\\n                 * batch_evaluation += v12 * QC_EVAL\\n                 * batch_evaluation += v13 * QARITH_EVAL\\n                 * batch_evaluation += v14 * QSORT_EVAL_LOC\\n                 * batch_evaluation += v15 * QELLIPTIC_EVAL_LOC\\n                 * batch_evaluation += v16 * QAUX_EVAL_LOC\\n                 * batch_evaluation += v17 * SIGMA1_EVAL_LOC\\n                 * batch_evaluation += v18 * SIGMA2_EVAL_LOC\\n                 * batch_evaluation += v19 * SIGMA3_EVAL_LOC\\n                 * batch_evaluation += v20 * SIGMA4_EVAL_LOC\\n                 */\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V7_LOC), mload(Q1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V8_LOC), mload(Q2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V9_LOC), mload(Q3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V10_LOC), mload(Q4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V11_LOC), mload(QM_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V12_LOC), mload(QC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V13_LOC), mload(QARITH_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V14_LOC), mload(QSORT_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V15_LOC), mload(QELLIPTIC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V16_LOC), mload(QAUX_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V17_LOC), mload(SIGMA1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V18_LOC), mload(SIGMA2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V19_LOC), mload(SIGMA3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V20_LOC), mload(SIGMA4_EVAL_LOC), p), p)\\n\\n                /**\\n                 * batch_evaluation += v21 * (table1(zw) * u + table1(z))\\n                 * batch_evaluation += v22 * (table2(zw) * u + table2(z))\\n                 * batch_evaluation += v23 * (table3(zw) * u + table3(z))\\n                 * batch_evaluation += v24 * (table4(zw) * u + table4(z))\\n                 * batch_evaluation += v25 * table_type_eval\\n                 * batch_evaluation += v26 * id1_eval\\n                 * batch_evaluation += v27 * id2_eval\\n                 * batch_evaluation += v28 * id3_eval\\n                 * batch_evaluation += v29 * id4_eval\\n                 * batch_evaluation += quotient_eval\\n                 */\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V21_LOC),\\n                            addmod(mulmod(mload(TABLE1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE1_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V22_LOC),\\n                            addmod(mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V23_LOC),\\n                            addmod(mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V24_LOC),\\n                            addmod(mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V25_LOC), mload(TABLE_TYPE_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V26_LOC), mload(ID1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V27_LOC), mload(ID2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V28_LOC), mload(ID3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V29_LOC), mload(ID4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mload(QUOTIENT_EVAL_LOC), p)\\n\\n                mstore(0x00, 0x01) // [1].x\\n                mstore(0x20, 0x02) // [1].y\\n                mstore(0x40, sub(p, batch_evaluation))\\n                // accumulator_2 = -[1].(batch_evaluation)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                mstore(OPENING_COMMITMENT_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING PREAMBLE\\n             */\\n            {\\n                let u := mload(C_U_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                // VALIDATE PI_Z\\n                {\\n                    let x := mload(PI_Z_X_LOC)\\n                    let y := mload(PI_Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(0x40, zeta)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                // VALIDATE PI_Z_OMEGA\\n                {\\n                    let x := mload(PI_Z_OMEGA_X_LOC)\\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\\n                // accumulator_2 = u.zeta.omega.[PI_Z_OMEGA]\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // PAIRING_RHS = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                mstore(0x00, mload(PI_Z_X_LOC))\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, u)\\n                success := and(success, staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40))\\n                // PAIRING_LHS = [PI_Z] + [PI_Z_OMEGA] * u\\n                success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                // negate lhs y-coordinate\\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\\n\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    // VALIDATE RECURSIVE P1\\n                    {\\n                        let x := mload(RECURSIVE_P1_X_LOC)\\n                        let y := mload(RECURSIVE_P1_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n\\n                    // compute u.u.[recursive_p1] and write into 0x60\\n                    mstore(0x40, mulmod(u, u, p))\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\\n                    // VALIDATE RECURSIVE P2\\n                    {\\n                        let x := mload(RECURSIVE_P2_X_LOC)\\n                        let y := mload(RECURSIVE_P2_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n                    // compute u.u.[recursive_p2] and write into 0x00\\n                    // 0x40 still contains u*u\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\\n\\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                }\\n\\n                if iszero(success) {\\n                    mstore(0x0, EC_SCALAR_MUL_FAILURE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(PAIRING_PREAMBLE_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING\\n             */\\n            {\\n                // rhs paired with [1]_2\\n                // lhs paired with [x]_2\\n\\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\\n\\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\\n                mstore(0x100, mload(G2X_X0_LOC))\\n                mstore(0x120, mload(G2X_X1_LOC))\\n                mstore(0x140, mload(G2X_Y0_LOC))\\n                mstore(0x160, mload(G2X_Y1_LOC))\\n\\n                success := staticcall(gas(), 8, 0x00, 0x180, 0x00, 0x20)\\n                mstore(PAIRING_SUCCESS_FLAG, success)\\n                mstore(RESULT_FLAG, mload(0x00))\\n            }\\n            if iszero(\\n                and(\\n                    and(and(mload(PAIRING_SUCCESS_FLAG), mload(RESULT_FLAG)), mload(PAIRING_PREAMBLE_SUCCESS_FLAG)),\\n                    mload(OPENING_COMMITMENT_SUCCESS_FLAG)\\n                )\\n            ) {\\n                mstore(0x0, PROOF_FAILURE_SELECTOR)\\n                revert(0x00, 0x04)\\n            }\\n            {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20) // Proof succeeded!\\n            }\\n        }\\n    }\\n}\\n\\ncontract RecoveryUltraVerifier is RecoveryBaseUltraVerifier {\\n    function getVerificationKeyHash() public pure override(RecoveryBaseUltraVerifier) returns (bytes32) {\\n        return RecoveryUltraVerificationKey.verificationKeyHash();\\n    }\\n\\n    function loadVerificationKey(uint256 vk, uint256 _omegaInverseLoc) internal pure virtual override(RecoveryBaseUltraVerifier) {\\n        RecoveryUltraVerificationKey.loadVerificationKey(vk, _omegaInverseLoc);\\n    }\\n}\\n\",\"keccak256\":\"0x18711465bc1be252b2f70ada974e86d4b7ce3f50961e2a0d19c4e08e391c63cb\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b5060405162003e4438038062003e448339810160408190526200003491620000c9565b6001600160a01b0383166080526040518290829062000053906200009e565b6001600160a01b03928316815291166020820152604001604051809103906000f08015801562000087573d6000803e3d6000fd5b506001600160a01b031660a0525062000113915050565b6122d08062001b7483390190565b80516001600160a01b0381168114620000c457600080fd5b919050565b600080600060608486031215620000df57600080fd5b620000ea84620000ac565b9250620000fa60208501620000ac565b91506200010a60408501620000ac565b90509250925092565b60805160a051611a2d6200014760003960008181610226015281816104630152610632015260006103980152611a2d6000f3fe60806040523480156200001157600080fd5b5060043610620000ab5760003560e01c8063837b23dc116200006e578063837b23dc14620001c4578063a03dd85214620001db578063a608260914620001f2578063ad95b3b41462000209578063fc6eddc8146200022057600080fd5b80630b07f8f814620000b057806338cb879414620000f257806347a7f4a01462000155578063572b6c05146200017d578063699e21f51462000194575b600080fd5b620000c7620000c136600462000a95565b62000248565b6040805182516001600160a01b03168152602092830151151592810192909252015b60405180910390f35b620001356200010336600462000a95565b80516020818301810180516000825292820191909301209152546001600160a01b03811690600160a01b900460ff1682565b604080516001600160a01b039093168352901515602083015201620000e9565b6200016c6200016636600462000b22565b620002ad565b6040519015158152602001620000e9565b6200016c6200018e36600462000be1565b62000396565b620001ab620001a536600462000bff565b620003c8565b6040516001600160a01b039091168152602001620000e9565b6200016c620001d536600462000ca3565b6200051a565b620001ab620001ec36600462000bff565b62000600565b6200016c6200020336600462000d61565b620006eb565b6200016c6200021a36600462000e41565b620007c8565b620001ab7f000000000000000000000000000000000000000000000000000000000000000081565b6040805180820190915260008082526020820152600080836040516200026f919062000f62565b90815260408051918290036020908101832083830190925290546001600160a01b038116835260ff600160a01b909104161515908201529392505050565b6000620002ba3362000396565b620002e25760405162461bcd60e51b8152600401620002d99062000f80565b60405180910390fd5b85620002ee81620008b4565b6000808860405162000301919062000f62565b9081526040519081900360200181205463f54a736360e01b82526001600160a01b03169150819063f54a73639062000344908a908a908a908a9060040162001027565b6020604051808303816000875af115801562000364573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200038a919062001057565b98975050505050505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b60008086604051620003db919062000f62565b9081526040519081900360200190205460ff600160a01b90910416156200042f576000866040516200040e919062000f62565b908152604051908190036020019020546001600160a01b0316905062000511565b600062000440878787878762000600565b90506001600160a01b0381163b80156200045d5750905062000511565b8360001b7f0000000000000000000000000000000000000000000000000000000000000000898989896040516024016200049b94939291906200107b565b60408051601f198184030181529181526020820180516001600160e01b0316630c4274f360e31b17905251620004d190620009dc565b620004de929190620010c0565b8190604051809103906000f5905080158015620004ff573d6000803e3d6000fd5b5092506200050e888462000927565b50505b95945050505050565b6000620005273362000396565b620005465760405162461bcd60e51b8152600401620002d99062000f80565b876200055281620008b4565b6000808a60405162000565919062000f62565b9081526040519081900360200181205463775a5d7f60e11b82526001600160a01b03169150819063eeb4bafe90620005ac908c908c908c908c908c908c90600401620010e6565b6020604051808303816000875af1158015620005cc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620005f2919062001057565b9a9950505050505050505050565b6000620006e18260001b604051806020016200061c90620009dc565b6020820181038252601f19601f820116604052507f0000000000000000000000000000000000000000000000000000000000000000898989896040516024016200066a94939291906200107b565b60408051601f19818403018152918152602080830180516001600160e01b0316630c4274f360e31b1790529051620006a593929101620010c0565b60408051601f1981840301815290829052620006c5929160200162001134565b604051602081830303815290604052805190602001206200099c565b9695505050505050565b6000620006f83362000396565b620007175760405162461bcd60e51b8152600401620002d99062000f80565b846200072381620008b4565b6000808760405162000736919062000f62565b9081526040519081900360200181205463ca6c974d60e01b82526001600160a01b03169150819063ca6c974d90620007779089908990899060040162001167565b6020604051808303816000875af115801562000797573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620007bd919062001057565b979650505050505050565b6000620007d53362000396565b620007f45760405162461bcd60e51b8152600401620002d99062000f80565b896200080081620008b4565b6000808c60405162000813919062000f62565b90815260405190819003602001812054637659accb60e01b82526001600160a01b031691508190637659accb906200085e908e908e908e908e908e908e908e908e906004016200122a565b6020604051808303816000875af11580156200087e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620008a4919062001057565b9c9b505050505050505050505050565b600081604051620008c6919062000f62565b9081526040519081900360200190205460ff600160a01b90910416620009245760405162461bcd60e51b81526020600482015260126024820152714c756e613a20496e76616c6964204c756e6160701b6044820152606401620002d9565b50565b6040805180820182526001600160a01b03831681526001602082015290516000906200095590859062000f62565b908152604051602091819003820190208251815493909201516001600160a01b039092166001600160a81b031990931692909217600160a01b911515919091021790555050565b6000620009ab838330620009b2565b9392505050565b6000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b61072780620012d183390190565b634e487b7160e01b600052604160045260246000fd5b600082601f83011262000a1257600080fd5b813567ffffffffffffffff8082111562000a305762000a30620009ea565b604051601f8301601f19908116603f0116810190828211818310171562000a5b5762000a5b620009ea565b8160405283815286602085880101111562000a7557600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121562000aa857600080fd5b813567ffffffffffffffff81111562000ac057600080fd5b62000ace8482850162000a00565b949350505050565b60008083601f84011262000ae957600080fd5b50813567ffffffffffffffff81111562000b0257600080fd5b60208301915083602082850101111562000b1b57600080fd5b9250929050565b60008060008060006080868803121562000b3b57600080fd5b853567ffffffffffffffff8082111562000b5457600080fd5b62000b6289838a0162000a00565b9650602088013591508082111562000b7957600080fd5b62000b8789838a0162000ad6565b909650945060408801359350606088013591508082111562000ba857600080fd5b5062000bb78882890162000a00565b9150509295509295909350565b80356001600160a01b038116811462000bdc57600080fd5b919050565b60006020828403121562000bf457600080fd5b620009ab8262000bc4565b600080600080600060a0868803121562000c1857600080fd5b853567ffffffffffffffff8082111562000c3157600080fd5b62000c3f89838a0162000a00565b9650602088013591508082111562000c5657600080fd5b62000c6489838a0162000a00565b955060408801359450606088013591508082111562000c8257600080fd5b5062000c918882890162000a00565b95989497509295608001359392505050565b600080600080600080600060a0888a03121562000cbf57600080fd5b873567ffffffffffffffff8082111562000cd857600080fd5b62000ce68b838c0162000a00565b985060208a013591508082111562000cfd57600080fd5b62000d0b8b838c0162000ad6565b909850965086915062000d2160408b0162000bc4565b955060608a0135945060808a013591508082111562000d3f57600080fd5b5062000d4e8a828b0162000ad6565b989b979a50959850939692959293505050565b6000806000806060858703121562000d7857600080fd5b843567ffffffffffffffff8082111562000d9157600080fd5b62000d9f8883890162000a00565b9550602087013591508082111562000db657600080fd5b62000dc48883890162000ad6565b9095509350604087013591508082111562000dde57600080fd5b5062000ded8782880162000a00565b91505092959194509250565b60008083601f84011262000e0c57600080fd5b50813567ffffffffffffffff81111562000e2557600080fd5b6020830191508360208260051b850101111562000b1b57600080fd5b600080600080600080600080600060a08a8c03121562000e6057600080fd5b893567ffffffffffffffff8082111562000e7957600080fd5b62000e878d838e0162000a00565b9a5060208c013591508082111562000e9e57600080fd5b62000eac8d838e0162000ad6565b909a50985060408c013591508082111562000ec657600080fd5b62000ed48d838e0162000df9565b909850965060608c013591508082111562000eee57600080fd5b62000efc8d838e0162000df9565b909650945060808c013591508082111562000f1657600080fd5b5062000f258c828d0162000df9565b915080935050809150509295985092959850929598565b60005b8381101562000f5957818101518382015260200162000f3f565b50506000910152565b6000825162000f7681846020870162000f3c565b9190910192915050565b60208082526030908201527f4c756e61466163746f72793a2063616c6c6572206973206e6f7420746865207460408201526f393ab9ba32b2103337b93bb0b93232b960811b606082015260800190565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b600081518084526200101381602086016020860162000f3c565b601f01601f19169290920160200192915050565b6060815260006200103d60608301868862000fd0565b8460208401528281036040840152620007bd818562000ff9565b6000602082840312156200106a57600080fd5b81518015158114620009ab57600080fd5b60808152600062001090608083018762000ff9565b8281036020840152620010a4818762000ff9565b90508460408401528281036060840152620007bd818562000ff9565b6001600160a01b038316815260406020820181905260009062000ace9083018462000ff9565b608081526000620010fc60808301888a62000fd0565b6001600160a01b03871660208401526040830186905282810360608401526200112781858762000fd0565b9998505050505050505050565b600083516200114881846020880162000f3c565b8351908301906200115e81836020880162000f3c565b01949350505050565b6040815260006200117d60408301858762000fd0565b8281036020840152620006e1818562000ff9565b81835260006020808501808196508560051b810191508460005b878110156200121d5782840389528135601e19883603018112620011ce57600080fd5b8701858101903567ffffffffffffffff811115620011eb57600080fd5b803603821315620011fb57600080fd5b6200120886828462000fd0565b9a87019a9550505090840190600101620011ab565b5091979650505050505050565b60808152600062001240608083018a8c62000fd0565b8281036020848101919091528882528991810160005b8a81101562001286576001600160a01b03620012728562000bc4565b168252928201929082019060010162001256565b5084810360408601528781526001600160fb1b03881115620012a757600080fd5b8760051b92508289838301379091018381038201606085015290620008a481830186886200119156fe608060405260405161072738038061072783398101604081905261002291610319565b61002e82826000610035565b5050610436565b61003e8361006b565b60008251118061004b5750805b156100665761006483836100ab60201b6100291760201c565b505b505050565b610074816100d7565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606100d08383604051806060016040528060278152602001610700602791396101a9565b9392505050565b6100ea8161022260201b6100551760201c565b6101515760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084015b60405180910390fd5b806101887f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b61023160201b6100641760201c565b80546001600160a01b0319166001600160a01b039290921691909117905550565b6060600080856001600160a01b0316856040516101c691906103e7565b600060405180830381855af49150503d8060008114610201576040519150601f19603f3d011682016040523d82523d6000602084013e610206565b606091505b50909250905061021886838387610234565b9695505050505050565b6001600160a01b03163b151590565b90565b606083156102a357825160000361029c576001600160a01b0385163b61029c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610148565b50816102ad565b6102ad83836102b5565b949350505050565b8151156102c55781518083602001fd5b8060405162461bcd60e51b81526004016101489190610403565b634e487b7160e01b600052604160045260246000fd5b60005b838110156103105781810151838201526020016102f8565b50506000910152565b6000806040838503121561032c57600080fd5b82516001600160a01b038116811461034357600080fd5b60208401519092506001600160401b038082111561036057600080fd5b818501915085601f83011261037457600080fd5b815181811115610386576103866102df565b604051601f8201601f19908116603f011681019083821181831017156103ae576103ae6102df565b816040528281528860208487010111156103c757600080fd5b6103d88360208301602088016102f5565b80955050505050509250929050565b600082516103f98184602087016102f5565b9190910192915050565b60208152600082518060208401526104228160408501602087016102f5565b601f01601f19169190910160400192915050565b6102bb806104456000396000f3fe60806040523661001357610011610017565b005b6100115b610027610022610067565b61009f565b565b606061004e838360405180606001604052806027815260200161025f602791396100c3565b9392505050565b6001600160a01b03163b151590565b90565b600061009a7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b905090565b3660008037600080366000845af43d6000803e8080156100be573d6000f35b3d6000fd5b6060600080856001600160a01b0316856040516100e0919061020f565b600060405180830381855af49150503d806000811461011b576040519150601f19603f3d011682016040523d82523d6000602084013e610120565b606091505b50915091506101318683838761013b565b9695505050505050565b606083156101af5782516000036101a8576001600160a01b0385163b6101a85760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064015b60405180910390fd5b50816101b9565b6101b983836101c1565b949350505050565b8151156101d15781518083602001fd5b8060405162461bcd60e51b815260040161019f919061022b565b60005b838110156102065781810151838201526020016101ee565b50506000910152565b600082516102218184602087016101eb565b9190910192915050565b602081526000825180602084015261024a8160408501602087016101eb565b601f01601f1916919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220df5e088a16650cdc3010db20ecd1e2b26729605480c947e2f8d77aac24e8ff8464736f6c63430008110033416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212201ce93aafabcdfc3dbe8b31512cd5a125d4abfcaa23f53846909c2a5596b6e49d64736f6c6343000811003360c06040523480156200001157600080fd5b50604051620022d0380380620022d0833981016040819052620000349162000069565b6001600160a01b039182166080521660a052620000a1565b80516001600160a01b03811681146200006457600080fd5b919050565b600080604083850312156200007d57600080fd5b62000088836200004c565b915062000098602084016200004c565b90509250929050565b60805160a0516121fb620000d560003960008181610369015261079a0152600081816102fd01526108fc01526121fb6000f3fe60806040526004361061012c5760003560e01c80637659accb116100a5578063bc197c811161006c578063bc197c811461038b578063ca6c974d146103ba578063d087d288146103cd578063eeb4bafe146103e2578063f23a6e61146103f5578063f54a73631461042257005b80637659accb146102c3578063820e93f5146102d65780638315ed85146102eb5780638ee06ddd14610337578063a8b56de21461035757005b80632e334452116100f45780632e3344521461021957806352a9674b146102435780636102495c146102585780636213a7981461026e57806362ccde241461028e57806364ddaf19146102a357005b806223de291461013557806301ffc9a71461015a578063150b7a021461018f57806329d8a8a1146101d45780632a1690cb146101f757005b3661013357005b005b34801561014157600080fd5b506101336101503660046116e0565b5050505050505050565b34801561016657600080fd5b5061017a61017536600461178a565b610435565b60405190151581526020015b60405180910390f35b34801561019b57600080fd5b506101bb6101aa3660046117b4565b630a85bd0160e11b95945050505050565b6040516001600160e01b03199091168152602001610186565b3480156101e057600080fd5b506101e9610487565b604051908152602001610186565b34801561020357600080fd5b5061020c610553565b6040516101869190611872565b34801561022557600080fd5b5061022e610574565b60408051928352602083019190915201610186565b34801561024f57600080fd5b5061020c61059b565b34801561026457600080fd5b506101e960035481565b34801561027a57600080fd5b50610133610289366004611948565b610629565b34801561029a57600080fd5b5061020c610747565b3480156102af57600080fd5b5061017a6102be3660046119d9565b610754565b61017a6102d1366004611a5e565b61081d565b3480156102e257600080fd5b5061020c610884565b3480156102f757600080fd5b5061031f7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610186565b34801561034357600080fd5b5061017a6103523660046119d9565b610891565b34801561036357600080fd5b5061031f7f000000000000000000000000000000000000000000000000000000000000000081565b34801561039757600080fd5b506101bb6103a6366004611b0d565b63bc197c8160e01b98975050505050505050565b61017a6103c8366004611ba6565b610985565b3480156103d957600080fd5b506005546101e9565b61017a6103f0366004611c0e565b6109e4565b34801561040157600080fd5b506101bb610410366004611c9a565b63f23a6e6160e01b9695505050505050565b61017a610430366004611cff565b610a47565b60006001600160e01b03198216630a85bd0160e11b148061046657506001600160e01b03198216630271189760e51b145b8061048157506001600160e01b031982166301ffc9a760e01b145b92915050565b60008060008060006105226002805461049f90611d58565b80601f01602080910402602001604051908101604052809291908181526020018280546104cb90611d58565b80156105185780601f106104ed57610100808354040283529160200191610518565b820191906000526020600020905b8154815290600101906020018083116104fb57829003601f168201915b5050505050610aa7565b965096509650965050505061054a84848461054461053f60055490565b610b06565b85610b86565b94505050505090565b606060006105676002805461049f90611d58565b5092979650505050505050565b60008060008061058a6002805461049f90611d58565b509499939850929650505050505050565b600180546105a890611d58565b80601f01602080910402602001604051908101604052809291908181526020018280546105d490611d58565b80156106215780601f106105f657610100808354040283529160200191610621565b820191906000526020600020905b81548152906001019060200180831161060457829003601f168201915b505050505081565b600054610100900460ff16158080156106495750600054600160ff909116105b806106635750303b158015610663575060005460ff166001145b6106cb5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b6000805460ff1916600117905580156106ee576000805461ff0019166101001790555b6106fa85858585610ddb565b8015610740576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b600280546105a890611d58565b60008061077061076b61076660055490565b610e06565b610e98565b9050600061078082600354610f19565b604051633a94343960e21b81529091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063ea50d0e4906107d390889088908690600401611d92565b602060405180830381865afa1580156107f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108149190611e0b565b95945050505050565b60006108298989610fbd565b6108675760405162461bcd60e51b815260206004820152600f60248201526e496e76616c696420706173736b657960881b60448201526064016106c2565b610875878787878787611001565b50600198975050505050505050565b600480546105a890611d58565b60008060008060008060006108ac6002805461049f90611d58565b9650965096509650509550955060006108d38585856108cd61053f60055490565b86610b86565b905060006108e288888461118b565b604051633a94343960e21b81529091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063ea50d0e490610935908e908e908690600401611d92565b602060405180830381865afa158015610952573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109769190611e0b565b9b9a5050505050505050505050565b60006109918484611284565b6109d05760405162461bcd60e51b815260206004820152601060248201526f496e76616c6964207265636f7665727960801b60448201526064016106c2565b6109d98261129e565b5060015b9392505050565b60006109f08787610fbd565b610a2e5760405162461bcd60e51b815260206004820152600f60248201526e496e76616c696420706173736b657960881b60448201526064016106c2565b610a3a858585856112ae565b5060019695505050505050565b6000610a538585611284565b610a925760405162461bcd60e51b815260206004820152601060248201526f496e76616c6964207265636f7665727960801b60448201526064016106c2565b610a9c83836112f5565b506001949350505050565b600080606080600060606000806000806000806000808e806020019051810190610ad19190611e95565b9650965096509650965096509650868686868686869d509d509d509d509d509d509d5050505050505050919395979092949650565b60606000600283604051602001610b1f91815260200190565b60408051601f1981840301815290829052610b3991611f61565b602060405180830381855afa158015610b56573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190610b799190611f7d565b90506109dd81602061130b565b6000846001600160f81b0319168587602081518110610ba757610ba7611f96565b0160200151166001600160f81b03191614610bd557604051637e49a3c960e11b815260040160405180910390fd5b600083516001600160401b03811115610bf057610bf0611885565b6040519080825280601f01601f191660200182016040528015610c1a576020820181803683370190505b509050610c2c858483518460006114a6565b5080604051602001610c3e9190611f61565b6040516020818303038152906040528051906020012084604051602001610c659190611f61565b6040516020818303038152906040528051906020012014610c995760405163ebab5d2960e01b815260040160405180910390fd5b600087516020610ca99190611fc2565b6001600160401b03811115610cc057610cc0611885565b6040519080825280601f01601f191660200182016040528015610cea576020820181803683370190505b509050610cfd8860008a518460006114a6565b50610d7e600287604051610d119190611f61565b602060405180830381855afa158015610d2e573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190610d519190611f7d565b604051602001610d6391815260200190565b60405160208183030381529060405260006020848c516114a6565b50600281604051610d8f9190611f61565b602060405180830381855afa158015610dac573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190610dcf9190611f7d565b98975050505050505050565b6001610de7858261201b565b506002610df4848261201b565b5060038290556004610740828261201b565b60606000610e1383611534565b60010190506000816001600160401b03811115610e3257610e32611885565b6040519080825280601f01601f191660200182016040528015610e5c576020820181803683370190505b5090508181016020015b600019016f181899199a1a9b1b9c1cb0b131b232b360811b600a86061a8153600a8504945084610e6657509392505050565b6000806040518060400160405280601a81526020017f19457468657265756d205369676e6564204d6573736167653a0a00000000000081525090506000610edf8451610e06565b90506000828286604051602001610ef8939291906120da565b60408051601f19818403018152919052805160209091012095945050505050565b604080516021808252610440820190925260609160009190602082016104208036833701905050905060005b6020811015610f9657610f67858260208110610f6357610f63611f96565b1a90565b828281518110610f7957610f79611f96565b602090810291909101015280610f8e8161211d565b915050610f45565b508281602081518110610fab57610fab611f96565b60209081029190910101529392505050565b6000806000806000806000610fd86002805461049f90611d58565b9650965096509650509550955060006108d38585856108cd61053f600580546001810190915590565b8481148015611017575082158061101757508281145b6110595760405162461bcd60e51b815260206004820152601360248201527277726f6e67206172726179206c656e6774687360681b60448201526064016106c2565b600083900361110f5760005b85811015611109576110f787878381811061108257611082611f96565b90506020020160208101906110979190612136565b60008585858181106110ab576110ab611f96565b90506020028101906110bd9190612151565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061160c92505050565b806111018161211d565b915050611065565b50611183565b60005b858110156111815761116f87878381811061112f5761112f611f96565b90506020020160208101906111449190612136565b86868481811061115657611156611f96565b905060200201358585858181106110ab576110ab611f96565b806111798161211d565b915050611112565b505b505050505050565b604080516060808252610c2082019092526000908260208201610c008036833701905050905060005b602081101561127b576111d2868260208110610f6357610f63611f96565b8282815181106111e4576111e4611f96565b602002602001018181525050611205858260208110610f6357610f63611f96565b82611211836020611fc2565b8151811061122157611221611f96565b602002602001018181525050611242848260208110610f6357610f63611f96565b8261124e836040611fc2565b8151811061125e5761125e611f96565b6020908102919091010152806112738161211d565b9150506111b4565b50949350505050565b60008061077061076b610766600580546001810190915590565b60026112aa828261201b565b5050565b6112ef848484848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061160c92505050565b50505050565b60038290556004611306828261201b565b505050565b6060600061131a836002612197565b611325906002611fc2565b6001600160401b0381111561133c5761133c611885565b6040519080825280601f01601f191660200182016040528015611366576020820181803683370190505b509050600360fc1b8160008151811061138157611381611f96565b60200101906001600160f81b031916908160001a905350600f60fb1b816001815181106113b0576113b0611f96565b60200101906001600160f81b031916908160001a90535060006113d4846002612197565b6113df906001611fc2565b90505b6001811115611457576f181899199a1a9b1b9c1cb0b131b232b360811b85600f166010811061141357611413611f96565b1a60f81b82828151811061142957611429611f96565b60200101906001600160f81b031916908160001a90535060049490941c93611450816121ae565b90506113e2565b5083156109dd5760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e7460448201526064016106c2565b606060006114b48386611fc2565b905080845110156114c457600080fd5b60006114d1876020611fc2565b905060006114e0856020611fc2565b90505b866114ef896020611fc2565b6114f99190611fc2565b821015611527578882015186820152611513602083611fc2565b9150611520602082611fc2565b90506114e3565b5093979650505050505050565b60008072184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b83106115735772184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b830492506040015b6d04ee2d6d415b85acef8100000000831061159f576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc1000083106115bd57662386f26fc10000830492506010015b6305f5e10083106115d5576305f5e100830492506008015b61271083106115e957612710830492506004015b606483106115fb576064830492506002015b600a83106104815760010192915050565b600080846001600160a01b031684846040516116289190611f61565b60006040518083038185875af1925050503d8060008114611665576040519150601f19603f3d011682016040523d82523d6000602084013e61166a565b606091505b50915091508161074057805160208201fd5b80356001600160a01b038116811461169357600080fd5b919050565b60008083601f8401126116aa57600080fd5b5081356001600160401b038111156116c157600080fd5b6020830191508360208285010111156116d957600080fd5b9250929050565b60008060008060008060008060c0898b0312156116fc57600080fd5b6117058961167c565b975061171360208a0161167c565b965061172160408a0161167c565b95506060890135945060808901356001600160401b038082111561174457600080fd5b6117508c838d01611698565b909650945060a08b013591508082111561176957600080fd5b506117768b828c01611698565b999c989b5096995094979396929594505050565b60006020828403121561179c57600080fd5b81356001600160e01b0319811681146109dd57600080fd5b6000806000806000608086880312156117cc57600080fd5b6117d58661167c565b94506117e36020870161167c565b93506040860135925060608601356001600160401b0381111561180557600080fd5b61181188828901611698565b969995985093965092949392505050565b60005b8381101561183d578181015183820152602001611825565b50506000910152565b6000815180845261185e816020860160208601611822565b601f01601f19169290920160200192915050565b6020815260006109dd6020830184611846565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156118c3576118c3611885565b604052919050565b60006001600160401b038211156118e4576118e4611885565b50601f01601f191660200190565b600082601f83011261190357600080fd5b8135611916611911826118cb565b61189b565b81815284602083860101111561192b57600080fd5b816020850160208301376000918101602001919091529392505050565b6000806000806080858703121561195e57600080fd5b84356001600160401b038082111561197557600080fd5b611981888389016118f2565b9550602087013591508082111561199757600080fd5b6119a3888389016118f2565b94506040870135935060608701359150808211156119c057600080fd5b506119cd878288016118f2565b91505092959194509250565b600080602083850312156119ec57600080fd5b82356001600160401b03811115611a0257600080fd5b611a0e85828601611698565b90969095509350505050565b60008083601f840112611a2c57600080fd5b5081356001600160401b03811115611a4357600080fd5b6020830191508360208260051b85010111156116d957600080fd5b6000806000806000806000806080898b031215611a7a57600080fd5b88356001600160401b0380821115611a9157600080fd5b611a9d8c838d01611698565b909a50985060208b0135915080821115611ab657600080fd5b611ac28c838d01611a1a565b909850965060408b0135915080821115611adb57600080fd5b611ae78c838d01611a1a565b909650945060608b0135915080821115611b0057600080fd5b506117768b828c01611a1a565b60008060008060008060008060a0898b031215611b2957600080fd5b611b328961167c565b9750611b4060208a0161167c565b965060408901356001600160401b0380821115611b5c57600080fd5b611b688c838d01611a1a565b909850965060608b0135915080821115611b8157600080fd5b611b8d8c838d01611a1a565b909650945060808b013591508082111561176957600080fd5b600080600060408486031215611bbb57600080fd5b83356001600160401b0380821115611bd257600080fd5b611bde87838801611698565b90955093506020860135915080821115611bf757600080fd5b50611c04868287016118f2565b9150509250925092565b60008060008060008060808789031215611c2757600080fd5b86356001600160401b0380821115611c3e57600080fd5b611c4a8a838b01611698565b9098509650869150611c5e60208a0161167c565b9550604089013594506060890135915080821115611c7b57600080fd5b50611c8889828a01611698565b979a9699509497509295939492505050565b60008060008060008060a08789031215611cb357600080fd5b611cbc8761167c565b9550611cca6020880161167c565b9450604087013593506060870135925060808701356001600160401b03811115611cf357600080fd5b611c8889828a01611698565b60008060008060608587031215611d1557600080fd5b84356001600160401b0380821115611d2c57600080fd5b611d3888838901611698565b90965094506020870135935060408701359150808211156119c057600080fd5b600181811c90821680611d6c57607f821691505b602082108103611d8c57634e487b7160e01b600052602260045260246000fd5b50919050565b60408152826040820152828460608301376000606084830101526000601f19601f8501168201606081016020606085840301818601528186518084526080850191508288019450600093505b80841015611dfe5784518252938201936001939093019290820190611dde565b5098975050505050505050565b600060208284031215611e1d57600080fd5b815180151581146109dd57600080fd5b6000611e3b611911846118cb565b9050828152838383011115611e4f57600080fd5b6109dd836020830184611822565b600082601f830112611e6e57600080fd5b6109dd83835160208501611e2d565b80516001600160f81b03198116811461169357600080fd5b600080600080600080600060e0888a031215611eb057600080fd5b875196506020880151955060408801516001600160401b0380821115611ed557600080fd5b818a0191508a601f830112611ee957600080fd5b611ef88b835160208501611e2d565b965060608a0151915080821115611f0e57600080fd5b611f1a8b838c01611e5d565b9550611f2860808b01611e7d565b945060a08a0151915080821115611f3e57600080fd5b50611f4b8a828b01611e5d565b92505060c0880151905092959891949750929550565b60008251611f73818460208701611822565b9190910192915050565b600060208284031215611f8f57600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8082018082111561048157610481611fac565b601f82111561130657600081815260208120601f850160051c81016020861015611ffc5750805b601f850160051c820191505b8181101561118357828155600101612008565b81516001600160401b0381111561203457612034611885565b612048816120428454611d58565b84611fd5565b602080601f83116001811461207d57600084156120655750858301515b600019600386901b1c1916600185901b178555611183565b600085815260208120601f198616915b828110156120ac5788860151825594840194600190910190840161208d565b50858210156120ca5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b600084516120ec818460208901611822565b845190830190612100818360208901611822565b8451910190612113818360208801611822565b0195945050505050565b60006001820161212f5761212f611fac565b5060010190565b60006020828403121561214857600080fd5b6109dd8261167c565b6000808335601e1984360301811261216857600080fd5b8301803591506001600160401b0382111561218257600080fd5b6020019150368190038213156116d957600080fd5b808202811582820484141761048157610481611fac565b6000816121bd576121bd611fac565b50600019019056fea2646970667358221220800ed371bda24141e3bc1c5aa41924570e29db8803491a74c0bf2a8382b5493e64736f6c63430008110033",
  "deployedBytecode": "0x60806040523480156200001157600080fd5b5060043610620000ab5760003560e01c8063837b23dc116200006e578063837b23dc14620001c4578063a03dd85214620001db578063a608260914620001f2578063ad95b3b41462000209578063fc6eddc8146200022057600080fd5b80630b07f8f814620000b057806338cb879414620000f257806347a7f4a01462000155578063572b6c05146200017d578063699e21f51462000194575b600080fd5b620000c7620000c136600462000a95565b62000248565b6040805182516001600160a01b03168152602092830151151592810192909252015b60405180910390f35b620001356200010336600462000a95565b80516020818301810180516000825292820191909301209152546001600160a01b03811690600160a01b900460ff1682565b604080516001600160a01b039093168352901515602083015201620000e9565b6200016c6200016636600462000b22565b620002ad565b6040519015158152602001620000e9565b6200016c6200018e36600462000be1565b62000396565b620001ab620001a536600462000bff565b620003c8565b6040516001600160a01b039091168152602001620000e9565b6200016c620001d536600462000ca3565b6200051a565b620001ab620001ec36600462000bff565b62000600565b6200016c6200020336600462000d61565b620006eb565b6200016c6200021a36600462000e41565b620007c8565b620001ab7f000000000000000000000000000000000000000000000000000000000000000081565b6040805180820190915260008082526020820152600080836040516200026f919062000f62565b90815260408051918290036020908101832083830190925290546001600160a01b038116835260ff600160a01b909104161515908201529392505050565b6000620002ba3362000396565b620002e25760405162461bcd60e51b8152600401620002d99062000f80565b60405180910390fd5b85620002ee81620008b4565b6000808860405162000301919062000f62565b9081526040519081900360200181205463f54a736360e01b82526001600160a01b03169150819063f54a73639062000344908a908a908a908a9060040162001027565b6020604051808303816000875af115801562000364573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200038a919062001057565b98975050505050505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b60008086604051620003db919062000f62565b9081526040519081900360200190205460ff600160a01b90910416156200042f576000866040516200040e919062000f62565b908152604051908190036020019020546001600160a01b0316905062000511565b600062000440878787878762000600565b90506001600160a01b0381163b80156200045d5750905062000511565b8360001b7f0000000000000000000000000000000000000000000000000000000000000000898989896040516024016200049b94939291906200107b565b60408051601f198184030181529181526020820180516001600160e01b0316630c4274f360e31b17905251620004d190620009dc565b620004de929190620010c0565b8190604051809103906000f5905080158015620004ff573d6000803e3d6000fd5b5092506200050e888462000927565b50505b95945050505050565b6000620005273362000396565b620005465760405162461bcd60e51b8152600401620002d99062000f80565b876200055281620008b4565b6000808a60405162000565919062000f62565b9081526040519081900360200181205463775a5d7f60e11b82526001600160a01b03169150819063eeb4bafe90620005ac908c908c908c908c908c908c90600401620010e6565b6020604051808303816000875af1158015620005cc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620005f2919062001057565b9a9950505050505050505050565b6000620006e18260001b604051806020016200061c90620009dc565b6020820181038252601f19601f820116604052507f0000000000000000000000000000000000000000000000000000000000000000898989896040516024016200066a94939291906200107b565b60408051601f19818403018152918152602080830180516001600160e01b0316630c4274f360e31b1790529051620006a593929101620010c0565b60408051601f1981840301815290829052620006c5929160200162001134565b604051602081830303815290604052805190602001206200099c565b9695505050505050565b6000620006f83362000396565b620007175760405162461bcd60e51b8152600401620002d99062000f80565b846200072381620008b4565b6000808760405162000736919062000f62565b9081526040519081900360200181205463ca6c974d60e01b82526001600160a01b03169150819063ca6c974d90620007779089908990899060040162001167565b6020604051808303816000875af115801562000797573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620007bd919062001057565b979650505050505050565b6000620007d53362000396565b620007f45760405162461bcd60e51b8152600401620002d99062000f80565b896200080081620008b4565b6000808c60405162000813919062000f62565b90815260405190819003602001812054637659accb60e01b82526001600160a01b031691508190637659accb906200085e908e908e908e908e908e908e908e908e906004016200122a565b6020604051808303816000875af11580156200087e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620008a4919062001057565b9c9b505050505050505050505050565b600081604051620008c6919062000f62565b9081526040519081900360200190205460ff600160a01b90910416620009245760405162461bcd60e51b81526020600482015260126024820152714c756e613a20496e76616c6964204c756e6160701b6044820152606401620002d9565b50565b6040805180820182526001600160a01b03831681526001602082015290516000906200095590859062000f62565b908152604051602091819003820190208251815493909201516001600160a01b039092166001600160a81b031990931692909217600160a01b911515919091021790555050565b6000620009ab838330620009b2565b9392505050565b6000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b61072780620012d183390190565b634e487b7160e01b600052604160045260246000fd5b600082601f83011262000a1257600080fd5b813567ffffffffffffffff8082111562000a305762000a30620009ea565b604051601f8301601f19908116603f0116810190828211818310171562000a5b5762000a5b620009ea565b8160405283815286602085880101111562000a7557600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121562000aa857600080fd5b813567ffffffffffffffff81111562000ac057600080fd5b62000ace8482850162000a00565b949350505050565b60008083601f84011262000ae957600080fd5b50813567ffffffffffffffff81111562000b0257600080fd5b60208301915083602082850101111562000b1b57600080fd5b9250929050565b60008060008060006080868803121562000b3b57600080fd5b853567ffffffffffffffff8082111562000b5457600080fd5b62000b6289838a0162000a00565b9650602088013591508082111562000b7957600080fd5b62000b8789838a0162000ad6565b909650945060408801359350606088013591508082111562000ba857600080fd5b5062000bb78882890162000a00565b9150509295509295909350565b80356001600160a01b038116811462000bdc57600080fd5b919050565b60006020828403121562000bf457600080fd5b620009ab8262000bc4565b600080600080600060a0868803121562000c1857600080fd5b853567ffffffffffffffff8082111562000c3157600080fd5b62000c3f89838a0162000a00565b9650602088013591508082111562000c5657600080fd5b62000c6489838a0162000a00565b955060408801359450606088013591508082111562000c8257600080fd5b5062000c918882890162000a00565b95989497509295608001359392505050565b600080600080600080600060a0888a03121562000cbf57600080fd5b873567ffffffffffffffff8082111562000cd857600080fd5b62000ce68b838c0162000a00565b985060208a013591508082111562000cfd57600080fd5b62000d0b8b838c0162000ad6565b909850965086915062000d2160408b0162000bc4565b955060608a0135945060808a013591508082111562000d3f57600080fd5b5062000d4e8a828b0162000ad6565b989b979a50959850939692959293505050565b6000806000806060858703121562000d7857600080fd5b843567ffffffffffffffff8082111562000d9157600080fd5b62000d9f8883890162000a00565b9550602087013591508082111562000db657600080fd5b62000dc48883890162000ad6565b9095509350604087013591508082111562000dde57600080fd5b5062000ded8782880162000a00565b91505092959194509250565b60008083601f84011262000e0c57600080fd5b50813567ffffffffffffffff81111562000e2557600080fd5b6020830191508360208260051b850101111562000b1b57600080fd5b600080600080600080600080600060a08a8c03121562000e6057600080fd5b893567ffffffffffffffff8082111562000e7957600080fd5b62000e878d838e0162000a00565b9a5060208c013591508082111562000e9e57600080fd5b62000eac8d838e0162000ad6565b909a50985060408c013591508082111562000ec657600080fd5b62000ed48d838e0162000df9565b909850965060608c013591508082111562000eee57600080fd5b62000efc8d838e0162000df9565b909650945060808c013591508082111562000f1657600080fd5b5062000f258c828d0162000df9565b915080935050809150509295985092959850929598565b60005b8381101562000f5957818101518382015260200162000f3f565b50506000910152565b6000825162000f7681846020870162000f3c565b9190910192915050565b60208082526030908201527f4c756e61466163746f72793a2063616c6c6572206973206e6f7420746865207460408201526f393ab9ba32b2103337b93bb0b93232b960811b606082015260800190565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b600081518084526200101381602086016020860162000f3c565b601f01601f19169290920160200192915050565b6060815260006200103d60608301868862000fd0565b8460208401528281036040840152620007bd818562000ff9565b6000602082840312156200106a57600080fd5b81518015158114620009ab57600080fd5b60808152600062001090608083018762000ff9565b8281036020840152620010a4818762000ff9565b90508460408401528281036060840152620007bd818562000ff9565b6001600160a01b038316815260406020820181905260009062000ace9083018462000ff9565b608081526000620010fc60808301888a62000fd0565b6001600160a01b03871660208401526040830186905282810360608401526200112781858762000fd0565b9998505050505050505050565b600083516200114881846020880162000f3c565b8351908301906200115e81836020880162000f3c565b01949350505050565b6040815260006200117d60408301858762000fd0565b8281036020840152620006e1818562000ff9565b81835260006020808501808196508560051b810191508460005b878110156200121d5782840389528135601e19883603018112620011ce57600080fd5b8701858101903567ffffffffffffffff811115620011eb57600080fd5b803603821315620011fb57600080fd5b6200120886828462000fd0565b9a87019a9550505090840190600101620011ab565b5091979650505050505050565b60808152600062001240608083018a8c62000fd0565b8281036020848101919091528882528991810160005b8a81101562001286576001600160a01b03620012728562000bc4565b168252928201929082019060010162001256565b5084810360408601528781526001600160fb1b03881115620012a757600080fd5b8760051b92508289838301379091018381038201606085015290620008a481830186886200119156fe608060405260405161072738038061072783398101604081905261002291610319565b61002e82826000610035565b5050610436565b61003e8361006b565b60008251118061004b5750805b156100665761006483836100ab60201b6100291760201c565b505b505050565b610074816100d7565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606100d08383604051806060016040528060278152602001610700602791396101a9565b9392505050565b6100ea8161022260201b6100551760201c565b6101515760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084015b60405180910390fd5b806101887f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b61023160201b6100641760201c565b80546001600160a01b0319166001600160a01b039290921691909117905550565b6060600080856001600160a01b0316856040516101c691906103e7565b600060405180830381855af49150503d8060008114610201576040519150601f19603f3d011682016040523d82523d6000602084013e610206565b606091505b50909250905061021886838387610234565b9695505050505050565b6001600160a01b03163b151590565b90565b606083156102a357825160000361029c576001600160a01b0385163b61029c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610148565b50816102ad565b6102ad83836102b5565b949350505050565b8151156102c55781518083602001fd5b8060405162461bcd60e51b81526004016101489190610403565b634e487b7160e01b600052604160045260246000fd5b60005b838110156103105781810151838201526020016102f8565b50506000910152565b6000806040838503121561032c57600080fd5b82516001600160a01b038116811461034357600080fd5b60208401519092506001600160401b038082111561036057600080fd5b818501915085601f83011261037457600080fd5b815181811115610386576103866102df565b604051601f8201601f19908116603f011681019083821181831017156103ae576103ae6102df565b816040528281528860208487010111156103c757600080fd5b6103d88360208301602088016102f5565b80955050505050509250929050565b600082516103f98184602087016102f5565b9190910192915050565b60208152600082518060208401526104228160408501602087016102f5565b601f01601f19169190910160400192915050565b6102bb806104456000396000f3fe60806040523661001357610011610017565b005b6100115b610027610022610067565b61009f565b565b606061004e838360405180606001604052806027815260200161025f602791396100c3565b9392505050565b6001600160a01b03163b151590565b90565b600061009a7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b905090565b3660008037600080366000845af43d6000803e8080156100be573d6000f35b3d6000fd5b6060600080856001600160a01b0316856040516100e0919061020f565b600060405180830381855af49150503d806000811461011b576040519150601f19603f3d011682016040523d82523d6000602084013e610120565b606091505b50915091506101318683838761013b565b9695505050505050565b606083156101af5782516000036101a8576001600160a01b0385163b6101a85760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064015b60405180910390fd5b50816101b9565b6101b983836101c1565b949350505050565b8151156101d15781518083602001fd5b8060405162461bcd60e51b815260040161019f919061022b565b60005b838110156102065781810151838201526020016101ee565b50506000910152565b600082516102218184602087016101eb565b9190910192915050565b602081526000825180602084015261024a8160408501602087016101eb565b601f01601f1916919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220df5e088a16650cdc3010db20ecd1e2b26729605480c947e2f8d77aac24e8ff8464736f6c63430008110033416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212201ce93aafabcdfc3dbe8b31512cd5a125d4abfcaa23f53846909c2a5596b6e49d64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3563,
        "contract": "contracts/LunaFactory.sol:LunaFactory",
        "label": "LunaNameToDetails",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_string_memory_ptr,t_struct(LunaDetails)3558_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_string_memory_ptr,t_struct(LunaDetails)3558_storage)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => struct LunaStorage.LunaDetails)",
        "numberOfBytes": "32",
        "value": "t_struct(LunaDetails)3558_storage"
      },
      "t_string_memory_ptr": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(LunaDetails)3558_storage": {
        "encoding": "inplace",
        "label": "struct LunaStorage.LunaDetails",
        "members": [
          {
            "astId": 3555,
            "contract": "contracts/LunaFactory.sol:LunaFactory",
            "label": "walletAddress",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 3557,
            "contract": "contracts/LunaFactory.sol:LunaFactory",
            "label": "isUsed",
            "offset": 20,
            "slot": "0",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "32"
      }
    }
  }
}